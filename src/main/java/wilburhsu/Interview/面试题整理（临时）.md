项目难点考虑的方向：数据一致性，幂等性，时效性



从实现分类：

- 聚簇索引
- 辅助索引（也称二级索引或者非聚簇索引）

从功能上分类：

- 普通索引
- 唯一索引
- 主键索引（一种特殊的唯一索引，一个表只能有一个主键，不允许有空值）
- 复合索引
- 外键索引
- 全文索引

1. InnoDB 通过主键聚簇数据

2. 如果没有定义主键且没有定义聚集索引， MySQL 会选择第一个唯一的非空列代替
3. 如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引

MySql 的主键不能太大，如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点。

MySql 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整 B+树，从而导致页分裂，严重影响性能。

B+ Tree 将所有的 data 数据都保存到了叶子节点中，非叶子节点只保存索引和指针

如果项目中使用了分库分表，我们通常都会需要一个主键进行 sharding，在实现上，可以保留自增主键，而逻辑主键用来作为唯一索引即可



索引模型：哈希索引、B+树索引，InnoDB引擎使用B+树索引

B+树和哈希的优缺点？

- 哈希表适用于只有等值查询的场景

- 无法利用索引完成排序

- 不支持多列联合索引的最左匹配规则

- 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

B+树的叶子结点可以存放什么

- 可以存放整行数据或或者主键的值

- 索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引

- 而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引

聚簇索引和非聚簇索引，在查询数据时的区别

- 主键索引树的叶子节点直接就是要查询的整行数据，而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询（称之为回表）

非主键索引一定会回表吗？

- 覆盖索引不需要回表

创建索引时考虑的因素

- 查询概率比较高，经常作为where条件的字段设置索引

联合索引字段顺序

- 最左匹配原则

MySQL 5.6 **索引下推、查询优化**

如何判断索引是否生效

- explain查看执行计划，explain字段

什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引（索引选择问题）

- **查询优化器**

慢SQL排查

#### SQL优化思路

预发跑sql explain

排除缓存干扰

看一下explains rows统计行数对不对，不对可以用analyze table  tablename矫正

存在回表的情况，使用覆盖索引

联合索引不能无限建，适用于高频场景

最左匹配原则，按照索引定义的字段顺序写sql，合理安排联合索引的顺序

5.6之后版本，索引下推，减少回表次数

唯一索引和普通索引的选择：**change buffer**

给字符串加索引，前缀索引，倒序存储，哈希

条件字段函数操作，隐式类型转换，隐式字符编码转换

数据库flush

行锁、表锁、间隙锁、同步场景