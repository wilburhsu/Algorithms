[toc]

# 问题总结
## 1 Java基础
### 1.1 Java基础语法、语言特性
#### Java语言的特性，和其他语言的区别
1. 一次编写，处处运行。   
C语言和C++编写的代码编译成的机器码依赖于特定的运行环境，当运行环境改变或者更换CPU之后原来的代码需要作出很大的变动才能正常运行   
Java语言可以在不改变代码的情况下在不同的运行环境下正常运行，因为Java代码编译的时候并不是编译成机器代码，而是字节码这种中间代码，通过JVM把字节码边运行边解释成适合的机器码，保证了正常运行   
2. 安全性、多线程、动态等等优秀的特点

#### Java为什么可以跨平台
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么，所以Java可以跨平台

#### 为什么Java中只有值传递？
[为什么Java中只有值传递](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/basis/why-there-only-value-passing-in-java.md)

[Java到底是值传递还是引用传递](https://www.zhihu.com/question/31203609/answer/51320855)

### 1.2 Java关键字及常用方法
#### `final`关键字的作用
final可以用来修饰类，方法和变量（成员变量或局部变量）。   
1. 修饰类：final修饰类的时，表明该类不能被其他类所继承。注意：final类中所有的成员方法都会隐式的定义为final方法
2. 修饰方法：final修饰方法，表明该方法不能被重写。final修饰方法，表明该方法不能被重写。   
**注意**：类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。
使用final方法的原因主要有两个：
    - 锁定方法，以防止继承类对其进行更改
    - 提升效率，在早期的java版本中，会将final方法转为内嵌调用，但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。
3. 修饰变量：
    - final修饰基本数据类型，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    - final修饰引用类型，则在对其初始化之后便不能再让其指向其他对象了（不能再指向其他引用地址），但该引用所指向的对象的内容可以发生变化
    - final修饰成员变量，表示常量，只能被赋值一次，必须要显式初始化并且赋值后值不可改变。有两种初始化方式：在变量声明的时候初始化；在这个变量所在的类的所有的构造函数中对这个变量赋初值
    - final修饰函数的参数类型，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值

#### `final` `finally` `finalize`区别
1. final：可以用来修饰类，方法和变量（成员变量或局部变量）。
2. finally：`finally`作为异常处理的一部分，它只能用在`try...catch`语句中，并且附带一个语句块，表示这段语句最终（一般情况下）不管有没有抛出异常一定会被执行，经常被用在需要释放资源的情况下
    > 几种不会执行finally的情况：
    > 1. 与`finally`对应的`try`语句块没有被执行
    > 2. 在`try`语句块中执行了`System.exit(0)`语句，终止了Java虚拟机的运行
    > 3. 当一个线程在执行`try`语句块或者`catch`语句块时被打断（interrupted）或者被终止（killed）
    > 4. 在线程运行`try`语句块或者`catch`语句块时，突然死机或者断电
3. finalize：finalize()在java.lang.Object中定义，每一个对象都有这个方法。
    - 这个方法在GC启动，该对象被回收的时候被调用。
    - GC可以回收大部分的对象（凡是new出来的对象，GC都能回收），所以一般不需要程序员去实现finalize()。
    - 特殊情况下，需要程序员实现finalize()，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize()，关闭这个链接

#### `try...catch...finally`中`return`的执行结果
因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。
```java
/**
 * try代码块已执行
 * try代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int noErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int hasErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 *
 * @return 2
 */
private int hasErrorWithoutFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    }
}
```
#### `==`和`equals()`区别
1. 基本数据类型，也称原始数据类型。
`byte` `short` `char` `int` `long` `float` `double` `boolean`他们之间的比较，用`==`，比较的是他们的值
2. 复合数据类型（类）：
`==`：比较的是对象在内存中的存放地址；
基类Object中的基类中定义的`equals()`的方法，默认返回`==`运算的结果；
某些类中重写了`equals()`方法：`String` `Integer` `Double` `Date`等，返回值相等的结果

#### `equal()`和`hashCode()`的联系和区别
在Java中任何一个对象都具备`equals()`和`hashcode()`两个方法，因为他们是在`Object`类中定义的
1. `equals()`方法用来判断两个对象是否相同，如果相同则返回`true`，否则返回`false`
2. `hashcode()`方法返回`int`，在`Object`类中默认实现是：将该对象的内存地址转换成一个整数返回

其中两个重要规范
1. 【为什么重写`equals()`方法的同时要重写`hashCode()`方法】
如果`equals()`返回`true`，即两个对象相同，那么他们的`hashCode()`应该相等。因此，若重写`equals()`方法，有必要重写`hashCode()`方法，确保通过`equals()`方法判断结果为`true`的两个对象具备相等的`hashCode()`返回值。注意：这个只是规范，如果你非要写一个类让`equals()`返回`true`而`hashCode()`返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG
2. 如果`equals()`返回`false`，即两个对象不相同，并不要求对这两个对象调用`hashCode()`方法得到两个不相同的数。说的简单点就是：如果两个对象不相同，他们的hashcode可能相同

【总结】根据这两个规范，可以得到如下推论： 
1. 如果两个对象`equals`，Java运行时环境会认为他们的`hashcode`一定相等【equals ＞ hashcode】
2. 如果两个对象不`equals`，他们的`hashcode`有可能相等
3. 如果两个对象`hashcode`相等，他们不一定`equals`【hashcode ≯ equals】
4. 如果两个对象`hashcode`不相等，他们一定不`equals` 

> `hashCode()`在哈希表中起作用，如`HashSet`、`HashMap`等。当我们向哈希表中添加对象`object`时，首先调用`hashCode()`方法计算`object`的哈希码，通过哈希码可以直接定位`object`在哈希表中的位置（一般是哈希码对哈希表大小取余）。如果该位置没有对象，可以直接将`object`插入该位置；如果该位置有对象，则调用`equals()`方法比较这些对象与`object`是否相等，如果相等，则不需要保存`object`；如果不相等，则将该对象加入到对应位置中

详细的解释：https://www.cnblogs.com/skywang12345/p/3324958.html

#### `static`关键字，是否可以覆盖一个`static`方法
static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。
- static标记的方法只能访问static变量或方法
- 非static标记的方法可以访问static或非static标记的变量或方法

#### `sleep()`和`wait()`的区别
1. `wait()`属于`Object`类，`sleep()`属于`Thread`类
2. 两者最主要的区别在于：`wait()`会释放对象锁而`sleep()`不会释放锁
    - 在调用`sleep()`方法的过程中，线程不会释放对象锁
    - 当调用`wait()`方法的时候，线程会放弃对象锁，进入等待此对象的等待池，只有针对此对象调用`notify()`或`notifyAll()`方法后本线程才进入对象锁池准备获取对象锁进入运行状态（线程不会自动苏醒，需要别的线程调用同一个对象上的`notify()`或者`notifyAll()`方法）。
    - `sleep()`方法执行完成后，线程会自动苏醒。
3. `wait()`需要在同步块中使用，`sleep()`可以在任何地方使用；
4. `sleep()`需要捕获异常，`wait()`不需要
5. `wait()`通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。

#### 为什么我们调用`start()`方法时会执行`run()`方法，为什么我们不能直接调用`run()`方法？
new一个Thread，线程进入了新建状态；调用`start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。`start()`会执行线程的相应准备工作，然后自动执行`run()`方法的内容，这是真正的多线程工作。而直接执行`run()`方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结： 调用`start()`方法方可启动线程并使线程进入就绪状态，而`run()`方法只是thread的一个普通方法调用，还是在主线程里执行。

### 1.3 面向对象
#### Java多态有哪几种，如何实现（重写如何定位到对应方法）
1. 多态：对象的多种形态。（严格意义上的多态，只是继承！）
    -  引用多态：
        1. 父类的引用可以指向本类的对象
        2. 父类的引用可以指向子类的对象
    - 方法多态：
        1. 创建本类对象时，调用的方法为本类方法
        2. 创建子类对象时，调用的方法为子类重写的方法或者继承的方法
2. 动态绑定
    ```java
    Object o = new GeometricObject();   // 声明类型为Object，实际类型为GeometricObject
    System.out.println(o.toString());
    ```
    1. 声明类型：一个变量必须被声明为某种类型，实例可以使用声明类型或它的子类型的构造方法创建
    2. 实际类型：被变量引用的对象的实际类型
    
    代码中，`o`调用的到底是哪个`toString()`方法是由`o`的实际类型决定的，这称为动态绑定。动态绑定的工作机制：假设对象`o`是类`C1` `C2` ... `C(i)` ... `C(n)`的实例，其中`C(i-1)` 是`C(i)`的子类，`C(n)`是最通用的类、`C1`是最特殊的类。在Java中`C(n)`是`Object`类。如果对象`o`调用一个方法p，那么Java虚拟机会依次在`C1` `C2` ... `C(n)`中查找方法p的实现，直到找到为止。一旦找到这个实现，就停止查找然后调用这个第一次找到的实现
    
    匹配方法的签名和绑定方法的实现是两个独立的事情：
    1. 引用变量的声明类型决定了编译时匹配哪个方法，编译器会在编译时，根据参数类型、参数个数、参数顺序找到匹配的方法（区分重载的方法）
    2. 实际类型决定Java虚拟机在运行时动态绑定方法的实现，一个方法可能在几个子类中都被实现

广义上的多态：https://www.runoob.com/java/java-polymorphism.html

#### 重载和重写的区别
- 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
- 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

#### 接口和抽象类的区别
1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

&nbsp; | 变量 | 构造方法 | 方法
:---:|:---:|:---:|:---:
抽象类 | 无限制 | 子类通过构造方法链调用构造方法，<br>抽象类不能用new操作符实例化<br> | 无限制
接口 | 所有的变量必须是<br>`public`或`static`或`final`<br> | 没有加构造方法。<br>接口不能用new操作符实例化<br> | 所有方法必须是公共的抽象示例方法

### 1.4 常用类、接口及集合类
#### `int` `Integer`的区别
1. `Integer`是`int`的包装类，`int`则是Java的一种基本数据类型
2. `Integer`变量必须实例化后才能使用，而int变量不需要 
3. `Integer`实际是对象的引用，当`new Integer()`时，实际上是生成一个指针指向此对象；而`int`则是直接存储数据值 
4. `Integer`的默认值是`null`，`int`的默认值是0

关于`Integer`和`int`进行比较的结果
1. 由于`Integer`变量实际上是对一个`Integer`对象的引用，所以两个通过`new`生成的`Integer`变量永远是不相等的（因为内存地址不同）

    ```java
    // result: false
    Integer a = new Integer(100);
    Integer b = new Integer(100);
    ```

2. 对于两个非`new`生成的`Integer`对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为`true`，如果两个变量的值不在此区间，则比较结果为`false`

    ```java
    // result: true
    Integer a = 100;
    Integer b = 100;
    
    // result: false
    a = 128;
    b = 128;
    ```
    java在编译`Integer i = 100;`时，会翻译成为`Integer i = Integer.valueOf(100);`，而Java API中对`Integer.valueOf()`定义如下：对于-128到127之间的数，会进行缓存

    ```java
    /**
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     */
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ```
3. 非`new Integer()`变量和`new Integer()`生成的变量比较时，结果为false
    1. 值在-128到127之间，非`new Integer()`变量在缓存中，`new Integer()`生成的变量为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 100;
    Integer b = new Integer(100);
    ```
    
    2. 值不在-128到127之间，两种方法生成的均为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 258;
    Integer b = new Integer(258);
    ```
    
4. Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）
   
    ```java
    // result: true
    Integer a = new Integer(100);
    int c = 100;
    ```

#### `String`，`StringBuffer`，`StringBuilder`区别，`String`为什么不可变，是否线程安全为什么
可变性
1. `String` 类中使用 `final` 关键字修饰字符数组来保存字符串，`private　final　char　value[]`，所以 `String` 对象是不可变的
2. `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[] value`，但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。
3. `StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是 `AbstractStringBuilder` 实现的。`AbstractStringBuilder` 源码：

    ```java
    //AbstractStringBuilder.java
    abstract class AbstractStringBuilder implements Appendable, CharSequence {
        char[] value;
        int count;
        AbstractStringBuilder() {
        }
        AbstractStringBuilder(int capacity) {
            value = new char[capacity];
        }
    ```

线程安全性
1. `String` 中的对象是不可变的，也就可以理解为常量，线程安全。
2. `AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。
    1. `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
    2. `StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。　

性能
1. `String` `StringBuffer` `StringBuilder`都是`final`类，内部都是`char[]`实现，三者在执行速度方面：`StringBuilder` > `StringBuffer` > `String`
2. 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
3. `StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 可以获得 10%~15% 左右的性能提升，但是要冒多线程不安全的风险。

使用总结
1. `String`，字符串常量，操作少量的数据用，类中定义的`char[]`是`final`的，不可变，因此是线程安全的
2. `StringBuilder`，字符串变量（非线程安全），单线程操作字符串缓冲区下操作大量数据
3. `StringBuffer`，字符串变量（线程安全），多线程操作字符串缓冲区下操作大量数据

补充说明
> 为什么`String`要设计成不可变：https://www.cnblogs.com/sessionbest/articles/8688569.html
> 在java中，`String`被设计成final类，那为什么平时使用时，`String`的值可以被改变呢？
字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对`String`对象值改变的时候，例如 `String a="A"`; `a="B"` 。a是`String`对象的一个引用（我们这里所说的`String`对象其实是指字符串常量），当`a="B"`执行时，并不是原本`String`对象(`"A"`)发生改变，而是创建一个新的对象(`"B"`)，令a引用它。    
> 笔试题：https://www.cnblogs.com/AmyZheng/p/9415064.html

#### `Comparable`接口和`Comparator`接口实现比较
1. Comparable

    `Comparable`接口中只有一个方法`compareTo()`，就是调用方法的当前对象`this`和`o`进行比较，若`this > o`则返回值大于0，`this = o`则返回值等于0，`this < o`则返回值小于0
    ```java
    public interface Comparable<T> {
        public int compareTo(T o);
    }
    ```
2. Comparator
   
    `Comparator`接口中方法很多，但是我们只需要实现一个`compare()`。
    > JDK8以后的新特性：在接口中用`default`修饰的方法可以有方法体，在实现接口的时候可以不用重写

    `compare()`比较`o1`和`o2`，`o1 > o2`则返回值大于0，以此类推。对于`compare()`来说`this`是谁不重要，所比较的两个对象都已经传入到方法中
    ```java
    public interface Comparator<T> {
        int compare(T o1, T o2);
        // default ... ...
    }
    ```
    `Comparator`可实现外部比较器，在我们设计类初时，并不需要它有比较功能，在后期扩展业务时，`Comparator`的存在可以使我们在不修改源代码的情况下来完成需求：只需要新定义一个比较器来实现`Comparator`，重写`compare()`方法并将类对象传进去
    ```java
    // 例子
    static class UserComparator implements Comparator<User> {
        @Override
        public int compare(User o1, User o2) {
            // ... ...
        }
    }
    ```

#### 常用集合类比较
集合 | 底层结构 | 存储类型 | 长度是否有上限 | 扩增/大小 | 线程安全 | 性能 | 备注
---|---|---|---|---|---|---|---
ArrayList | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/1.5倍 | 不安全 | 查询性能好 |
Vector | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | |
Stack | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | | 继承自Vector
LinkedList | 双向链表 | 顺序 | 无，直到内存满 | | 不安全 | 增加性能好 |
HashMap | | | 有，`MAXIMUM_CAPACITY = 1<<30`（1左移30位） | 自动扩增/2倍 | 不安全 | |

#### `ArrayList`的实现，为什么查找效率高
`ArrayList`采用数组数组实现。查找效率高，因为`ArrayList`是连续存放元素的，找到第一个元素的首地址，再加上每个元素的占据的字节大小就能定位到对应的元素

#### `Array` `ArrayList`区别
`ArrayList`可以算是`Array`（`[]`）的加强版，`ArrayList`可以被想象成一种会自动扩增容量的`Array`
1. 存储内容
    1. `Array`数组可存放基本类型或对象类型；`Array`数组在存放的时候一定是同种类型的元素
    2. `ArrayList`只能包含对象类型；`ArrayList`可存放不同类型的元素，因为`ArrayList`可以存储`Object`
2. 空间大小
    1. `Array`最高效，但是其容量固定且无法动态改变
    2. `ArrayList`动态增长，但牺牲效率。若空间不够，会扩容1.5倍，然后将所有元素复制到新数组中并抛弃旧数组，每次添加新的元素的时候都会检查内部数组的空间是否足够
3. 相互转换

    ```java
    // ArrayList => Array
    ArrayList<Integer> arrayList = new ArrayList(10);
    Integer[] array = arrayList.toArray(new Integer[20]);
    
    // Array => ArrayList
    Integer[] array = new Integer[10];
    ArrayList<Integer> arrayList = new ArrayList(Arrays.asList(array));
    ```

#### `ArrayList` `LinkedList`区别
集合类 | `ArrayList` | `LinkedList`
---|---|---
继承关系 | `Collection<-List<-ArrayList` | `Collection<-List<-LinkedList`
底层数据结构 | 数组 | 双向链表，带有头结点和尾结点 
存取类型 | 随机存取 | 顺序存取，头插LinkedFirst，尾插LinkedLast 
长度限制 | 有上限 `int hugeCapacity()` | 无上限 直到内存满
扩增/大小 | 自动扩增/1.5倍 | 
线程安全 | 不安全 | 不安全
性能 | 查询操作性能好 | 插入操作性能好

#### `CopyOnWriteArrayList`类
`CopyOnWriteArrayList` 是 `ArrayList` 的线程安全版本
1. 写操作：使用了一种叫写时复制的方法，当有新元素添加到`CopyOnWriteArrayList`时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。整个`add()`操作都是在锁的保护下进行，避免在多线程并发`add()`的时候，复制出多个副本，导致最终的数组数据不是我们期望的
2. 读操作：读操作是可以不用加锁。如果有线程并发的读，则分几种情况： 
    1. 如果写操作未完成，那么直接读取原数组的数据
    2. 如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据
    3. 如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据

#### `HashMap` 中`put`方法过程
1. 首先将传入的 Key 做 hash 运算计算出 hashcode，再与该hashcode值的高16位进行异或运算得到最终的hash值，然后根据数组长度进行取模计算， `(n - 1) & hash` ，得到在数组中的 index 下标。过程如下图：
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/C044925B259445C0B458A9EFB200EACE/5644)

2. 如果索引指定的位置值为空（没有hash碰撞），则在索引数组中新建一个k-v的新节点；
如果当前位置存在元素的话，则判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同通过拉链法解决冲突，如第3、4点描述

3. 如果碰撞了，以链表的方式将冲突的值链接到后面，如下图：
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/4838C1EF605D49EEBB866E8F77AC579B/5647)

4. 当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE26a8630358d0ae7b41ad544f382d8d66/13536)

5. 如果 `HashMap` 中的元素个数超过索引数组容量 * 负载因子（loadFactor）时，就会进行数组扩容（`resize`），即扩大一倍，然后重新计算每个元素在数组中的位置。HashMap默认容量为 16，负载因子为 0.75。

总结整个 `put` 方法流程：
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/D9618649877C4714B1A449BE18B75699/5653)

#### `HashMap` 的长度为什么是2的幂次方
1. 由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。
2. 当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小

#### `HashMap`基于什么数据结构实现
1. JDK1.8以前
    1. 数据结构：链表散列，数组+链表
    2. 键值对内部类：`Entry`
2. JDK1.8及以后
    1. 数据结构：数组+链表+红黑树（红黑树可提高效率）
    2. 键值对内部类：`Node`&`TreeNode`
    ```java
    static class Node<K,V> implements Map.Entry<K,V>{}
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V>{}
    ```

#### `HashMap`如何处理hash冲突
链地址法
1. 计算出hash值，计算位置（因为n为table长度，为2的幂，故可用位运算计算余数）`i = (n - 1) & hash`
2. 若当前发生hash冲突
    - 找到相同key，则用待插入值覆盖原有值，返回旧值
    - 未找到相同key，则插入node，返回null
        1. 红黑树：添加节点
        2. 链表：在尾部插入

#### 有1000个数据存在hashmap中，实际的数量是多少，考虑负载因子和扩容
我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面已经说过，即使是1000，HashMap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 * 1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适

#### `HashMap` `CurrentHashMap` `LinkedHashMap` `HashTable`区别
接口`java.util.Map`，Map主要用于存储健值对，根据键得到值，因此不允许键重复（重复则覆盖），但允许值重复
1. `Hashmap`

    ```java
    public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {}
    ```
    
    最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为`Null`，允许多条记录的值为`Null`；`HashMap`不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用`Collections`的`synchronizedMap`方法使`HashMap`具有同步的能力，或者使用`ConcurrentHashMap`
2. `HashTable`
   
    ```java
    public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, java.io.Serializable {}
    ```
    
    与HashMap类似，它继承自`Dictionary`类，不同的是：它不允许记录的键或者值为`Null`，它支持线程的同步，即任一时刻只有一个线程能写`Hashtable`，因此也导致了`Hashtable`在写入时会比较慢
3. `LinkedHashMap`
   
    ```java
    public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {}
    ```
    
    `HashMap`的一个子类，保存了记录的插入顺序，在用`Iterator`遍历`LinkedHashMap`时，先得到的记录肯定是先插入的．也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比`HashMap`慢，不过有种情况例外，当`HashMap`容量很大，实际数据较少时，遍历起来可能会比`LinkedHashMap`慢，因为`LinkedHashMap`的遍历速度只和实际数据有关，和容量无关，而`HashMap`的遍历速度和容量有关
4. `ConcurrentHashMap`
   
    ```java
    public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {}
    public interface ConcurrentMap<K, V> extends Map<K, V> {}
    ```
    
    不允许key/value为空，`ConcurrentHashMap`线程安全
    1. JDK1.7中采用`Segment`+`HashEntry`实现，lock加在`Segment`上
    2. JDK1.8中采用`Node`+`CAS`+`Synchronized`实现

#### 如何让`HashMap`线程安全 | `HashTable`、`ConcurrentHashmap`如何实现线程安全
1. `HashTable`的方式：将容器中数据进行操作的方法用`synchronized`关键字修饰
2. `ConcurrentHashMap`的方式：
    - 采用分段锁思路，`segment`+`HashEntry`（JDK1.7）；
    - `Node`+`CAS`+`Synchronized`（JDK1.8）

#### `CurrentHashMap`实现线程安全的关键（JDK1.7 分段锁）
[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)
[漫画：什么是ConcurrentHashMap](https://zhuanlan.zhihu.com/p/31614308)

JDK1.7中采用`Segment`+`HashEntry`实现，lock加在`Segment`上。`Segment`继承了`ReentrantLock`，所以它就是一种可重入锁。在`ConcurrentHashMap`，一个`Segment`就是一个子哈希表，`Segment`里维护了一个`HashEntry`数组，并发环境下，对于不同`Segment`的数据进行操作是不用考虑锁竞争的，对于同一个Segment的操作才需考虑线程同步
1. `get()`方法：先定位`Segment`，再定位`HashEntry`。`get()`方法无需加锁，由于其中涉及到的共享变量都使用`volatile`修饰，`volatile`可以保证内存可见性，所以不会读取到过期数据
2. `put()`方法
    1. 定位segment并确保定位的Segment已初始化
    2. 调用Segment的put方法：`tryLock()`不成功时会遍历定位到的`HashEnry`位置的链表（遍历主要是为了使CPU缓存链表），若找不到，则创建`HashEntry`。`tryLock()`一定次数后，则lock。若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历

## 2 Java高级
### 2.1 I/O
#### 如何理解I/O

从计算机结构的视角来看的话，I/O描述了计算机系统与外部设备之间通信的过程。从应用程序的角度来看I/O：

为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为用户空间（User space）和内核空间（Kernel space ）。

我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。并且，用户空间的程序不能直接访问内核空间。当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。因此，用户进程想要执行 IO 操作的话，必须通过系统调用来间接访问内核空间。

我们在平常开发过程中接触最多的就是磁盘 IO（读写文件） 和网络 IO（网络请求和响应）。

从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。

当应用程序发起 I/O 调用后，会经历两个步骤：
1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

UNIX 系统下， IO 模型一共有 5 种： 同步阻塞 I/O、同步非阻塞 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。

#### Java 中 3 种常见 IO 模型

[Java I/O模型详解](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/basis/io%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.md)

1. BIO
    BIO 属于同步阻塞 IO 模型 。
    同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCEcedec4fe2355bde60348e62db38f28f0/13559)
    在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
2. NIO (Non-blocking/New I/O)
    Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。
    Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。
    先看同步非阻塞 IO 模型：
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE6263cc1708f7fd13ed2050819fb9041c/13567)
    同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。
    相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。
    但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。
    这个时候，I/O 多路复用模型 就上场了。
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE104b25b44856dbd83e9acfe5788a9d4d/13569)
    IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。
    目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
    -   select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
    -   epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。
    IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。

    Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE37ba34bd07ed22ba57fb77e2764794b3/13573)
    
3. AIO (Asynchronous I/O)
    AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。
    异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE824df6aa6088a41de9d7bf9e85776a4b/13575)
    目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。
4. 一图总结 Java 中的 BIO、NIO、AIO
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/WEBRESOURCE8d4e5c820d7819b5f0355a2474d16b8e/13577)

#### Java中的典型IO操作模式

1.  同步阻塞模式：Java中的BIO风格的API

    ```java
    Socket socket = getSocket();
    socket.getInputStream().read(); //读不到数据誓不返回
    ```

    该模式下，最直观的感受就是如果IO设备暂时没有数据可供读取，调用API就卡住了，如果数据一直不来就一直卡住

2.  同步非阻塞模式：Java中的NIO风格的API

    ```java
    SocketChannel socketChannel = getSocketChannel(); //获取non-blocking状态的Channel
    socketChannel.read(ByteBuffer.allocate(4)); //读不到数据就算了，立即返回0告诉你没有读到
    ```

    该模式下，通常需要不断调用API，直至读取到数据，不过好在函数调用不会卡住，想继续尝试读取或者先去做点其他事情再来读取都可以

3.  异步非阻塞模式：Java中的AIO风格的API

    ```java
    AsynchronousSocketChannel asynchronousSocketChannel = getAsynchronousSocketChannel();
    asynchronousSocketChannel.read(ByteBuffer.allocate(4), null, new CompletionHandler<Integer, Object>() {
        @Override
        public void completed(Integer result, Object attachment) {
            //读不到数据不会触发该回调来烦你，只有确实读取到数据，且把数据已经存在ByteBuffer中了，API才会通过此回调接口主动通知您
        }
        @Override
        public void failed(Throwable exc, Object attachment) {
        }
    });

    ```

    读不到数据不会触发该回调来烦你，只有确实读取到数据，且把数据已经存在`ByteBuffer`中了，API才会通过此回调接口主动通知你

### 2.2 多线程与并发
#### 线程有哪几种状态

操作系统中的线程有五种状态：NEW、READY、RUNNING、BLOCKED、DEAD

Java中的线程有六种状态（Thread源码中的状态）：NEW（新建）、RUNNABLE（运行）、BLOCKED（阻塞）、WAITING（无限等待）、TIME_WAITING（限期等待）、TERMINATED（结束），其中RUNNABLE包含操作系统的READY和RUNNING两种状态

#### 线程安全怎么理解

当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的

#### 实现多线程有几种实现方式
[https://www.cnblogs.com/songshu120/p/7966314.html](https://www.cnblogs.com/songshu120/p/7966314.html)
1. 继承`Thread`类创建线程类
    1. 定义`Thread`类的子类，并重写该类的`run()`方法，该`run()`方法的方法体就代表了线程要完成的任务，因此把`run()`方法称为执行体
    2. 创建`Thread`子类的实例，即创建了线程对象
    3. 调用线程对象的`start()`方法来启动该线程
2. 通过`Runnable`接口创建线程类：线程的执行流程很简单，当执行代码`start()`时，就会执行对象中重写的`run()`方法，该方法执行完成后，线程就消亡了
    1. 定义`Runnable`接口的实现类，并重写该接口的`run()`方法，该`run()`方法的方法体同样是该线程的线程执行体
    2. 创建`Runnable`实现类的实例，并以此实例作为`Thread`的`target`来创建`Thread`对象，该`Thread`对象才是真正的线程对象
    3. 调用线程对象的`start()`方法来启动该线程
3. 通过`Callable`和`Future`创建线程
    1. 创建`Callable`接口的实现类，并实现`call()`方法，该`call()`方法将作为线程执行体，并且有返回值
    2. 创建`Callable`实现类的实例，使用`FutureTask`类来包装`Callable`对象，该`FutureTask`对象封装了该`Callable`对象的`call()`方法的返回值（`FutureTask`是一个包装器，它通过接受`Callable`来创建，它同时实现了`Future`和`Runnable`接口）
    3. 使用`FutureTask`对象作为`Thread`对象的`target`创建并启动新线程
    4. 调用`FutureTask`对象的`get()`方法来获得子线程执行结束后的返回值

#### 实现`Runnable`接口要实现什么方法
[JAVA多线程实现的四种方式](https://www.cnblogs.com/felixzh/p/6036074.html)

Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。

其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。

1. 继承Thread类创建线程
    Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如：
    ```java
    public class MyThread extends Thread {  
    　　public void run() {  
    　　 System.out.println("MyThread.run()");  
    　　}  
    }  
     
    MyThread myThread1 = new MyThread();  
    MyThread myThread2 = new MyThread();  
    myThread1.start();  
    myThread2.start();
    ```
2. 实现Runnable接口创建线程
    如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，如下：
    ```java
    public class MyThread extends OtherClass implements Runnable {  
    　　public void run() {  
    　　 System.out.println("MyThread.run()");  
    　　}  
    }
    ```
    为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：
    ```java
    MyThread myThread = new MyThread();  
    Thread thread = new Thread(myThread);  
    thread.start(); 
    ```
    事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码：
    ```java
    public void run() {  
    　　if (target != null) {  
    　　 target.run();  
    　　}  
    }
    ```
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
    Callable接口（也只有一个方法）定义如下：
    ```java
    public interface Callable<V> { 
      V call（） throws Exception;
    }
    ```
    ```java
    public class SomeCallable<V> extends OtherClass implements Callable<V> {
        @Override
        public V call() throws Exception {
            // TODO Auto-generated method stub
            return null;
        }
    }
    ```
    ```java
    Callable<V> oneCallable = new SomeCallable<V>();   
    //由Callable<Integer>创建一个FutureTask<Integer>对象：   
    FutureTask<V> oneTask = new FutureTask<V>(oneCallable);   
    //注释：FutureTask<Integer>是一个包装器，它通过接受Callable<Integer>来创建，它同时实现了Future和Runnable接口
    //由FutureTask<Integer>创建一个Thread对象：
    Thread oneThread = new Thread(oneTask);   
    oneThread.start();   
    //至此，一个线程就创建完成了
    ```

4. 使用ExecutorService、Callable、Future实现有返回结果的线程
    - ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。
    - 可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。
    - 执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。
    注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。
    - 再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。
    - 下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：
    ```java
    import java.util.concurrent.*;
    import java.util.Date;
    import java.util.List;
    import java.util.ArrayList;
    
    /**
     * 有返回值的线程
     */
    @SuppressWarnings("unchecked")
    public class TestFinallyReturn {
        public static void main(String[] args) throws ExecutionException,
                InterruptedException {
            System.out.println("----程序开始运行----");
            Date date1 = new Date();
    
            int taskSize = 5;
            // 创建一个线程池  
            ExecutorService pool = Executors.newFixedThreadPool(taskSize);
            // 创建多个有返回值的任务  
            List<Future> list = new ArrayList<Future>();
            for (int i = 0; i < taskSize; i++) {
                Callable c = new MyCallable(i + " ");
                // 执行任务并获取Future对象  
                Future f = pool.submit(c);
                // System.out.println(">>>" + f.get().toString());  
                list.add(f);
            }
            // 关闭线程池  
            pool.shutdown();
    
            // 获取所有并发任务的运行结果  
            for (Future f : list) {
                // 从Future对象上获取任务的返回值，并输出到控制台  
                System.out.println(">>>" + f.get().toString());
            }
    
            Date date2 = new Date();
            System.out.println("----程序结束运行----，程序运行时间【"
                    + (date2.getTime() - date1.getTime()) + "毫秒】");
        }
    }
    
    class MyCallable implements Callable<Object> {
        private String taskNum;
    
        MyCallable(String taskNum) {
            this.taskNum = taskNum;
        }
    
        public Object call() throws Exception {
            System.out.println(">>>" + taskNum + "任务启动");
            Date dateTmp1 = new Date();
            Thread.sleep(1000);
            Date dateTmp2 = new Date();
            long time = dateTmp2.getTime() - dateTmp1.getTime();
            System.out.println(">>>" + taskNum + "任务终止");
            return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】";
        }
    }
    ```

#### 【自行整理】线程池`ThreadPoolExecutor`

[ThreadPoolExecutor概述](https://blog.csdn.net/wtopps/article/details/80682267)

1. `ThreadPoolExecutor`执行`execute()`方法分4步：
    1. 如果当前运行的线程少于`corePoolSize`，则创建新线程来执行任务（需要获取全局锁）
    2. 如果运行的线程等于或多于`corePoolSize`，则将任务加入`BlockingQueue`
    3. 如果无法将任务加入`BlockingQueue`（队列已满），则创建新的线程来处理任务（需要获取全局锁）
    4. 如果创建新线程将使当前运行的线程超出`maximumPoolSize`，任务将被拒绝，并调用`RejectedExecutionHandler.rejectedExecution()`方法
    
    `ThreadPoolExecutor`采取上述步骤的总体设计思路，是为了在执行`execute()`方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在`ThreadPoolExecutor`完成预热之后（当前运行的线程数大于等于`corePoolSize`），几乎所有的`execute()`方法调用都是执行步骤2，而步骤2不需要获取全局锁
    
    线程池处理流程图：
    
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/1938A70E46EA414AB7B7244FB2267EA1/5547)
2. 线程池中的线程执行任务分2步：
    1. 在`execute()`方法中创建一个线程时，会让这个线程执行当前任务
    2. 这个线程执行完任务后，会反复从`BlockingQueue`获取任务来执行

#### `ThreadPoolExcutor()`创建线程池的主要参数
```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```
1. `corePoolSize`：线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的`prestartAllCoreThreads()`方法，线程池会提前创建并启动所有基本线程
3. `maximumPoolSize`：线程池最大数量。线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果
3. `keepAliveTime`：空闲线程存活时间。一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
4. `milliseconds`：`TimeUnit`枚举类型的值，代表`keepAliveTime`时间单位
5. `runnableTaskQueue`：任务队列。用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列
    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序
    2. `LinkedBlockingQueue`：基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
    3. `SynchronousQueue`：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列
    4. `PriorityBlockingQueue`：具有优先级的无限阻塞队列
6. `ThreadFactory`：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架`guava`提供的`ThreadFactoryBuilder`可以快速给线程池里的线程设置有意义的名字
7. `RejectedExecutionHandler`：拒绝策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是`AbortPolicy`，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略：
    1. `AbortPolicy`：直接抛出异常
    2. `CallerRunsPolicy`：只用调用者所在线程来运行任务
    3. `DiscardOldestPolicy`：丢弃队列里最近的一个任务，并执行当前任务
    4. `DiscardPolicy`：不处理，丢弃掉

#### 线程池有什么用，为什么要使用线程池
1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。
3. 提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。

#### `synchronized` `ReentrantLock`区别

**1. 两者都是可重入锁**

- 都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的

- 两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

**2. `synchronized` 依赖于 JVM 而 `ReentrantLock` 依赖于 API**

- `synchronized`是java语言的关键字，是原生语法层面的互斥，是依赖于 JVM 实现的， 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。
- `ReentrantLock` 是 JDK 层面实现的（是JDK1.5之后提供的API层面的互斥锁，需要 `lock() `和` unlock() `方法配合` try`/`finally` 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

**3. 便利性及锁的细粒度和灵活度**

1. `synchronized`的使用比较方便简洁，并且由编译器去保证锁的加锁和释放
2. `ReenTrantLock`需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在`finally`中声明释放锁
3. 在锁的细粒度和灵活度和方面，`ReentrantLock`优于`synchronized`

**4. `ReentrantLock` 比 `synchronized` 增加了一些高级功能**

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：**①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）**

- **`ReentrantLock`提供了一种能够中断等待锁的线程的机制**，通过`lock.lockInterruptibly()`来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **`ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。** `ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。
- `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制，`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition() `方法。`Condition`是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个`Lock`对象中可以创建多个`Condition`实例（即对象监视器），**线程对象可以注册在指定的`Condition`中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用`notify()`/`notifyAll()`方法进行通知时，被通知的线程是由 JVM 选择的，用`ReentrantLock`类结合`Condition`实例可以实现“选择性通知”** ，这个功能非常重要，而且是`Condition`接口默认提供的。而`synchronized`关键字就相当于整个`Lock`对象中只有一个`Condition`实例，所有的线程都注册在它一个身上。如果执行`notifyAll()`方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而`Condition`实例的`signalAll()`方法 只会唤醒注册在该`Condition`实例中的所有等待线程。

如果你想使用上述功能，那么选择`ReentrantLock`是一个不错的选择。

**5. 性能已不是选择标准**

性能的区别：在`Synchronized`优化以前，`synchronized`的性能是比`ReenTrantLock`差很多，但是自从`Synchronized`引入了偏向锁、轻量级锁（自旋锁）后，两者的性能就差不多了。（在两种方法都可用的情况下，官方甚至建议使用`synchronized`）

> 其实`synchronized`的优化感觉就借鉴了`ReenTrantLock`中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。

#### `synchronized`底层实现

众所周知 `synchronized` 关键字是解决并发问题常用解决方案，有以下三种使用方式:

- 同步普通方法，锁的是当前对象。
- 同步静态方法，锁的是当前 `Class` 对象。
- 同步块，锁的是 `()` 中的对象。

实现原理： `JVM` 是通过进入、退出对象监视器( `Monitor` )来实现对方法、同步块的同步的。

**① synchronized 同步语句块的情况**

**synchronized 同步语句块的实现使用的是 monitor.enter 和 monitor.exit 指令，其中 monitor.enter 指令指向同步代码块的开始位置，monitor.exit 指令则指明同步代码块的结束位置。**具体实现是在编译之后在同步语句块调用前加入一个 `monitor.enter` 指令，在退出同步语句块和异常处插入 `monitor.exit` 的指令。其本质就是对一个对象监视器( `Monitor` )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor（monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因）的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。

如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放（即获取到锁的线程 `monitor.exit` ）后才能尝试继续获取锁。

**② synchronized 修饰方法的的情况**

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

**对原子性的保障**：

> Java虚拟机（JIT编译器）会在monitorenter（用于申请锁的字节码指令）对应的指令后临界区开始前的地方插入一个获取屏障。Java虚拟机会在临界区结束后monitorexit（用于释放锁的字节码指令）对应的指令前的地方插入一个释放屏障。这里，获取屏障和释放屏障一起保障了临界区内的任何读、写操作都无法被重排序到临界区之外，再加上锁的排他性，这使得临界区内的操作具有原子性。

**对可见性的保障**：

> synchronized 关键字对有序性的保障与volatile关键字对有序性的保障实现原理是一样的，也是通过释放屏障和获取屏障的配对使用实现的。释放屏障使得写线程在临界区中执行的读、写操作先于monitorexit对应的指令（相当于写操作）被提交，而获取屏障使得读线程必须在获得锁（相当于read-modify-write操作）之后才能够执行临界区中的操作。写线程以及读线程通过这种释放屏障和获取屏障的配对使用实现了有序性。

Java虚拟机也会在 monitorexit 对应的指令（相当于写操作）之后插入一个StoreLoad屏障。这个处理的目的与在volatile写操作之后插入一个StoreLoad屏障类似。该屏障充当了存储屏障，从而确保锁的持有线程在释放锁之前所执行的所有操作的结果能够到达高速缓存，并消除了存储转发的副作用。另外，该屏障禁止了monitorexit 对应的指令与其他同步块的monitorenter对应的指令进行重排序，这保障了monitorenter 与monitorexit 总是成对的，从而使synchronized 块的并列（一个synchronized 块之后又有其他synchronized 块）以及synchronized 块的嵌套（一个synchronized 块内包含其他synchronized 块）成为可能。

![](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/1EC45AFC0E224A278173172856CE8ADE/9319)



#### ==`synchronized`锁优化==


#### `volatile`的作用及适用场景

[Java 理论与实践：正确使用 volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)

[volatile总结](https://mp.weixin.qq.com/s/neDCzdVoXiger9D1hXBcag)

`volatile`是轻量级的`synchronized`，它在多处理器开发中保证了共享变量的“可见性”：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值

`volatile`关键字的**作用**体现在对其所修饰的变量的读、写操作上：

1. 保障可见性、保障有序性和保障long/double类型变量读写操作的原子性
  2. 提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。
  3. 读取一个volatile关键字修饰的变量会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的工作，从而保障了可见性。

写线程对`volatile`变量的写操作会产生类似于释放锁的效果，读线程对`volatile`变量的读操作会产生类似于获得锁的效果。因此，`volatile`具有保障有序性和可见性的作用。

`volatile`的**典型应用场景**包括：一，使用`volatile`变量作为状态标志；二，使用`volatile`保证可见性；三，使用`volatile`变量代替锁；四，使用`volatile`实现简易版读写锁。只能在有限的一些情形下使用`volatile`变量替代锁，例如：状态标志。要` volatile`变量提供理想的线程安全，必须同时满足下面两个条件：

1. 对变量的写操作不依赖于当前值：不能用作线程安全计数器：虽然增量操作`x++`看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，`volatile`不能提供必须的原子特性
2. 该变量没有包含在具有其他变量的不变式中

`volatile`与锁之间的**联系和区别**：

- `volatile`相当于轻量级锁。在线程安全保障方面与锁相同的是，`volatile`能够保障可见性、有序性；与锁不同的是`volatile`不具有排他性，也不会导致上下文切换。与锁类似，Java虚拟机实现`volatile`对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，`volatile`变量写操作相当于释放锁，`volatile`变量读操作相当于获得锁

#### `volatile`底层实现

`volatile` 的底层实现原理是内存屏障，Memory Barrier（Memory Fence），内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

保障有序性：最著名的例子就是单例模式里面的DCL（双重检查锁）

> Java虚拟机通过在`volatile`变量写操作之前插入一个释放屏障（释放屏障禁止了`volatile`写操作与该操作之前的任何读、写操作进行重排序），在`volatile`变量读操作之后插入一个获取屏障这种成对的释放和获取屏障的使用实现了`volatile`对有序性的保障

保障可见性：

> Java虚拟机通过在`volatile`变量写操作之后插入一个存储屏障（存储屏障具有冲刷处理器缓存的作用），在`volatile`变量读操作之前插入一个加载屏障这种成对的存储和加载屏障的使用实现了`volatile`对可见性的保障

对于`volatile`变量的写操作，Java虚拟机会在该操作之前插入一个释放屏障（Release Barrier）（`LoadStore`屏障与`StoreStore`屏障），并在该操作之后插入一个存储屏障（Store Barrier）（`StoreLoad`屏障）

![volatile变量写操作与内存屏障](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/133C760D87604491BEAA123E088EE531/9312)

对于`volatile`变量的读操作，Java虚拟机会在该操作之前插入一个加载屏障（Load Barrier）（`StoreLoad`屏障），并在该操作之后插入一个获取屏障（Acquire Barrier）（`LoadLoad`屏障与`LoadStore`屏障）

![volatile变量读操作与内存屏障](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/C3AB07CAFFB541FD8AF69D4E901720C6/9314)

注意：`volatile`关键字在原子性方面仅保障对被修饰的变量的读操作、写操作本身的原子性，如果要保障对volatile变量的赋值操作的原子性，那么这个赋值操作不能涉及任何共享变量（包括被赋值的`volatile`变量本身）的访问

#### 内存屏障

[内存屏障与synchronized、volatile的原理](https://www.jianshu.com/p/43af2cc32f90)

内存屏障是为了解决写缓冲器和无效化队列带来的有序性和可见性问题而引入的。

内存屏障是被插入两个CPU指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将写缓冲器的值写入高速缓存，清空无效队列，从而“附带”的保障了可见性。

举个例子说明：
     Store1     Store2    Load1     **StoreLoad屏障**     Store3     Load2     Load3

对于上面的一组CPU指令（Store表示写入指令，Load表示读取指令），`StoreLoad`屏障之前的`Store`指令无法与`StoreLoad`屏障之后的`Load`指令进行交换位置，即重排序。但是`StoreLoad`屏障之前和之后的指令是可以互换位置的，即Store1可以和Store2互换，Load2可以和Load3互换。

`StoreLoad`屏障的目的在于使屏障前的写操作的结果，对于屏障后的读操作是可见的。为了保障这一点，除了指令不能重排序外，`StoreLoad`屏障还会在写操作完之后，将写缓冲器中的条目冲刷入高速缓存或主内存；在读操作之前，清空无效化队列，从主内存或其他处理器的高速缓存中读取最新值到自己的内存。从而保障了数据在不同处理器之间是一致的，即可见性。

**基本内存屏障**

基本内存屏障可以分为：`LoadLoad`屏障、`LoadStore`屏障、`StoreStore`屏障和`StoreLoad`屏障。这些屏障可统一用XY来表示，XY屏障的作用是禁止屏障左侧的任何X操作与屏障右侧的任何Y操作之间进行重排序。

> **LoadLoad屏障：**
>  对于这样的语句  Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
>  **StoreStore屏障：**
>  对于这样的语句  Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
>  **LoadStore屏障：**
>  对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。
>  **StoreLoad屏障：**
>  对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

**内存屏障的分类**

- **按照可见性保障来划分**
   内存屏障可分为：加载屏障（Load Barrier）和存储屏障（Store Barrier）。
   加载屏障：`StoreLoad`屏障可充当加载屏障，作用是刷新处理器缓存，即清空无效化队列，使处理器在读取共享变量时，先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中
   存储屏障：`StoreLoad`屏障可充当存储屏障，作用是冲刷处理器缓存，即将写缓冲器内容写入高速缓存中，使处理器对共享变量的更新写入高速缓存或者主内存中
   这两个屏障一起保证了数据在多处理器之间是可见的。
- **按照有序性保障来划分**
   内存屏障分为：获取屏障（Acquire Barrier）和释放屏障（Release Barrier）。
   获取屏障：相当于`LoadLoad`屏障与`LoadStore`屏障的组合。在读操作后插入，禁止该读操作与其后的任何读写操作发生重排序；
   释放屏障：相当于`LoadStore`屏障与`StoreStore`屏障的组合。在一个写操作之前插入，禁止该写操作与其前面的任何读写操作发生重排序。
   这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外

#### `synchronized` 和 `volatile` 的区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在：

- `volatile`关键字是线程同步的轻量级实现，所以`volatile`性能肯定比`synchronized`关键字要好。但是`volatile`关键字只能用于变量而`synchronized`关键字可以修饰方法以及代码块。`synchronized`关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用`synchronized`关键字的场景还是更多一些。
- 多线程访问`volatile`关键字不会发生阻塞，而`synchronized`关键字可能会发生阻塞
- `volatile`关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized`关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而`synchronized`关键字解决的是多个线程之间访问资源的同步性。

#### `ThreadLocal`

[ThreadLocal解析](https://www.jianshu.com/p/98b68c97df9b)

`ThreadLocal`是一个本地线程副本变量工具类。多线程中的对象使用`ThreadLocal`维护时，`ThreadLocal`为每个使用该变量的线程分配一个独立的变量副本，每个线程可以独立地改变自己的副本，不会影响其他线程对应的副本

1. 实现思路：
    1. 每个`Thread`线程内部都有一个`ThreadLocalMap`，`ThreadLocalMap`里面存储一份线程自己的变量副本：
        1. key：线程本地对象（变量对应的`ThreadLocal`实例）
        2. value：线程的变量副本（变量的本地值）
    
    ```java
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // ThreadLocalMap内的Entry
    Entry(ThreadLocal<?> k, Object v) {}
    ```

    2. `Thread`内部的`ThreadLocalMap`由`ThreadLocal`维护的，由`ThreadLocal`负责向`ThreadLocalMap`获取和设置线程的变量值
2. 方法：
    1. `get()`：用于获取当前线程的副本变量值
    2. `set()`：用于保存当前线程的副本变量值
    3. `initialValue()`：为当前线程初始副本变量值
    4. `remove()`：移除当前前程的副本变量值。
3. Hash冲突解决：采用线性探测的方式，根据初始`key`的`hashcode`确定元素在`table`数组中的位置，如果发现这个位置上已经有其他`key`的元素，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。`ThreadLocalMap`解决Hash冲突的方式就是简单的步长加1或减1
   
    ```java
    // get()时使用
    private static int nextIndex(int i, int len) {
        return ((i + 1 < len) ? i + 1 : 0);
    }
    
    // set()时使用
    private static int prevIndex(int i, int len) {
        return ((i - 1 >= 0) ? i - 1 : len - 1);
    }
    ```
    
4. `ThreadLocalMap`的问题：由于`ThreadLocalMap`的`key`是弱引用，而`value`是强引用。这就导致`ThreadLocal`在没有外部对象强引用时，发生GC时弱引用`key`会被回收，而`value`不会回收，如果创建`ThreadLocal`的线程一直持续运行，那么这个`Entry`对象中的`value`就有可能一直得不到回收，发生内存泄露。避免泄漏：在调用`ThreadLocal`的`get()` `set()`方法使用完成后调用`remove()`方法，将`Entry`节点和`Map`的引用关系移除，这样整个`Entry`对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收
   
    ```java
    ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();
    try {
        threadLocal.set(new Session(1, "Misout的博客"));
        // 其它业务逻辑
    } finally {
        threadLocal.remove();
    }
    ```

#### ==`CountDownLatch` `CyclicBarrier` `Semaphore`== 

CountDownLatch 的两种典型用法

1. 某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：`new CountDownLatch(n)`，每当一个任务线程执行完毕，就将计数器减 1 `countdownlatch.countDown()`，当计数器的值变为 0 时，在`CountDownLatch上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 ：`new CountDownLatch(1)`，多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。

> CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的

CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：

1. CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。
2. 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的`await`方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；
3. CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过`getNumberWaiting()`，`isBroken()`这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；
4. CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。

#### Java中的锁有几种

1. `synchronized`关键字
2. `java.util.concurrent.locks`包下常用的类
    1. `ReentrantLock`：可重入锁，实现了`Lock`接口，并且提供了更多的方法
    2. `ReentrantReadWriteLock`：可重入的读写锁，实现了`ReadWriteLock`接口，最主要的有两个方法：`readLock()`和`writeLock()`用来获取读锁和写锁
    3. `StampedLock`：JDK8新增，该锁提供了三种模式的读写控制
        1. 写锁writeLock，是个排它锁或者叫独占锁
        2. 悲观读锁readLock，是个共享锁
        3. 乐观读锁tryOptimisticRead（在操作数据前并没有通过CAS设置锁的状态）

#### 乐观锁和悲观锁
1. 悲观锁
    1. 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）
    2. 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现
2. 乐观锁
    1. 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现
    2. 乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的

#### 公平锁和非公平锁

ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）

公平锁和非公平锁只有两处不同：

1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。
2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。

公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。

相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。

#### ==AQS==

AQS全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。

原理：采用state，通过对state的CAS判断来获取锁和解锁，并且存在等待队列和条件等待队来park相关线程之后入队等待，有公平和非公平两种模式来唤醒等待的线程。使用AQS是为了封装和抽象，通过封装公共的方法，减少代码重复。

AQS 的基本思想如下：

获取锁的逻辑

```
while(state 状态不允许获取) {
	if(队列中还没有此线程) {
		入队并阻塞
	}
}
当前线程出队
```

释放锁的逻辑

```
if(state 状态允许了) {
	恢复阻塞的线程(s)
}
```

要点

- 原子维护 state 状态
- 阻塞及恢复线程
- 维护队列

1) state 设计

    - state 使用 volatile 配合 cas 保证其修改时的原子性
    - state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想

2) 阻塞恢复设计

    - 早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume那么 suspend 将感知不到
    - 解决方法是使用 park & unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题
    - park & unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细
    - park 线程还可以通过 interrupt 打断

3) 队列设计

    - 使用了 FIFO 先入先出队列，并不支持优先级队列
    - 设计时借鉴了 CLH 队列，它是一种单向无锁队列

#### `ReadWriteLock`（读写锁）

#### `ReenrantLock`（可重入锁）实现原理

#### CAS（Atomic类保证原子性的原理）

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，具体过程：
1. 在内存地址V当中，存储着值为10的变量
2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11
3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11
4. 线程1开始提交更新，首先进行A和地址V的实际值比较Compare，发现A不等于V的实际值，提交失败
5. 线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋
6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的
7. 线程1进行SWAP，把地址V的值替换为B，也就是12
从思想上来说，synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

CAS的缺点：
1. CPU开销较大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
2. 不能保证代码块的原子性。CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了

#### CAS会产生什么问题
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
1. CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力
2. 不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了
3. ABA问题：CAS机制最大的问题所在。线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如：
    1. 一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知`A.next`为B，希望用CAS将栈顶替换为B
       
    ```
    graph LR
    A-->B
    ```
    
    2. 在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再`push D C A`，此时堆栈结构如下图，而对象B此时处于游离状态
       
    ```
    graph LR
    A-->C
    C-->D
    ```
    
    3. 此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上`B.next`为null，所以此时的情况变为
       
    ```
    graph LR
    B
    C-->D
    ```

### 2.3 设计模式   

#### ==单例模式==

#### ==工厂模式==

### ==2.4 反射==

## 3 JVM
周志明 深入理解Java虚拟机（重点看2、3、7、12、13这五章）

### 3.0 工作原理

Java源文件经过前端编译器（javac或ECJ）将.java文件（保存在硬盘中）编译为.class文件（Java字节码文件），然后JRE加载器从硬盘中读取Java字节码文件，载入系统分配给JVM的内存区域--运行数据区（Runtime Data Areas），然后执行引擎解释或编译类文件，再由即时编译器将字节码转化为特定CPU的机器码，CPU执行机器码。

<img src="http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/9A86BFE070D44B85B8F033716788C5B9/11804" style="zoom:70%;" />

### 3.1 内存管理
#### JVM内存模型，垃圾回收回收的是哪部分
*《深入理解Java虚拟机》P39 2.2*

![Java虚拟机运行时数据区域](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/5080B88526CE41BE9DCFD72BAC5FC3A5/9437)

区域 | 是否隔离 | 异常
---|---|---
程序计数栈 | 私有 | 唯一不会抛出OutOfMemoryError异常
Java虚拟机栈 | 私有 | OutOfMemoryError（无法申请到足够内存）；StackOverFlowError（请求栈深度大于虚拟机允许深度）
本地方法栈 | 私有 | OutOfMemoryError（无法申请到足够内存）；StackOverFlowError（请求栈深度大于虚拟机允许深度）
Java堆 | 共享 | OutOfMemoryError（堆中没有完成内存分配且堆无法再扩展）
方法区 | 共享 | OutOfMemoryError（无法满足内存分配需求）

1. 程序计数栈：一块较小的内存空间，是当前线程所执行的字节码的行号指示器。程序计数器只为执行java方法服务，执行Native方法时程序计数器为空
2. Java虚拟机栈：生命周期与线程相同，每个方法在执行的同时都会创建一个栈帧（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
3. 本地方法栈：与虚拟机栈所发挥的作用是非常相似的，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务
4. Java堆：在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”
5. 方法区：Non-Heap（非堆），各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

#### Java堆内存分代管理
1. 新生代：
    1. Eden空间：对象优先在Eden分配，空间不足时，虚拟机将发起一次Minor GC
    2. From Survivor空间、To Survivor空间：在Minor GC时交替使用，达到一定次数后，对象会晋升到老年代。如果Minor GC后仍存活的对象无法放入Survivor，则通过分配担保机制提前将对象转移到老年代
2. 老年代：大对象（需要大量连续内存空间）直接进入老年代；长期存活的对象进入老年代，对象每“熬过”一次Minor GC年龄增加一岁，到一定程度（默认为15岁）则晋升到老年代
3. 永久代：存储类定义、结构、字段、方法（数据及代码）以及常量在内的类相关数据
   
    > JDK 1.8中永久代被元空间（Metaspace）取代。两者本质类似，都是对JVM规范中方法区的实现，最大区别是：永久代的大小很难确定，对永久代的调优过程非常困难；元空间并不在虚拟机中，而是使用本地内存，最大可分配空间就是系统可用内存空间

#### 为什么需要两个Survivor区
设置两个Survivor区最大的好处就是解决了碎片化。

1. 如果只有一块Survivor区。Eden满了，第一次触发Minor GC，Eden中的存活对象被移动到Survivor区；再次触发Minor GC，Eden和Survivor各有一些存活对象： 
    1. 若此时把Eden区的存活对象直接放到Survivor区，这两部分对象所占有的内存是不连续的，导致了内存碎片化，严重影响Java程序的性能
    2. 若整理Survivor区后再放入Eden区的存活对象，则效率较低

2. 如果有两块Survivor区。第一次触发Minor GC，Eden中的存活对象就会被移动到第一块Survivor区S0，Eden被清空；再次触发Minor GC时，Eden和S0中的存活对象又会被复制送入第二块survivor区S1，S0和Eden被清空；然后下一轮S0与S1交换角色，如此循环往复。整个过程中，永远有一个Survivor区是空的，另一个非空的Survivor区无碎片

#### Eden区和Survivor区的分配的大小比例，为什么
IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保

#### 是否所有的对象和数组都会在堆上分配内存（逃逸分析）

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。

#### 堆的永久代和JVM方法栈有什么区别

两者并不等价，仅仅是HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代实现方法区，省去为方法区编写内存管理代码的工作

方法区是JVM规范中的一部分，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法去容易遇到内存溢出问题

#### 如何判断对象是否存活
1. 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能在被使用的
   
    主流的Java虚拟机里面没有选择引用计数算法来管理内存，其中主要的原因是它很难解决对象之间的相互循环引用的问题
2. 可达性分析法：在主流的商用程序语言中使用。基本思路就是通过一系列的名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（对象不可达）时，则证明此对象是不可用的
   
    ```
    graph TB
    A(CG Roots)
    B(Object1)
    C(Object2)
    D(Object3)
    E(Object4)
    F(Object5)
    G(Object6)
    H(Object7)
    A --> B
    B --> C
    B --> D
    D --> E
    F --> G
    F --> H
    ```
    
    在Java语言里，可作为GC Roots的对象包括下面几种：
    1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象
    2. 方法区中的类静态属性引用的对象
    3. 方法区中的常量引用的对象
    4. 本地方法栈中JNI（即一般说的Native方法）的引用的对象

#### ==JVM最大内存限制==

### 3.3 垃圾回收算法
#### 垃圾回收算法
*《深入理解Java虚拟机》P69 3.3*

1. 标记-清除算法：回收老年代。最基础的收集算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象

    后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：
    1. 效率问题，标记和清除两个过程的效率都不高；
    2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/CCCD0F9BF447477BA3ECF04B803955CD/5549)
2. 复制算法：回收新生代。为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价太高，将内存缩小为了原来的一半
    > 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间

    > 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法
    
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/80FB77033BB94CB4BD0178E3EF38D613/5551)
3. 标记-整理算法：回收老年代。标记过程仍然与“标记-清除”算法一样，标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
   

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/A22B08F3155249449053A4F7A4722311/5553)

4. 分代收集算法：当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法
    1. 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集
    2. 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收

#### 垃圾收集器
[深入理解JVM(3)——7种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/2BF6B271910C45AFA639AA88F524A8EF/5555)

如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器

收集器 | 执行方式 | 适用分代 | 算法 | 目标 | 适用场景
---|---|---|---|---|--- 
Serial | 串行 | 新生代 | 复制算法 | 响应速度优先 | 单CPU环境下的Client模式
Serial Old | 串行 | 老年代 | 标记-整理 | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案
ParNew | 并行 | 新生代 | 复制算法 | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合
Parallel Scavenge | 并行 | 新生代 | 复制算法 | 吞吐量优先 | 在后台运算而不需要太多交互的任务
Parallel Old | 并行 | 老年代 | 标记-整理 | 吞吐量优先 | 在后台运算而不需要太多交互的任务
CMS | 并发 | 老年代 | 标记-清除 | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用
G1 | 并发 | both | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS

#### CMS垃圾收集器

> - GC线程以用户线程之间并行执行，特点是低延迟
> - 主要用来回收老年代，主要回收算法是标记清除，所以容忍一点的内存碎片。混合标记整理，在内存碎片达到设定阈值的时候触发
> - 四个过程：初始标记，并发标记，重新标记，并发清除。初始标记和重新标记会触发短暂的Stop The World，并发标记和并发清除耗时较长，但是是与用户线程并发执行
> - CMS和G1 Stop The World的区别：G1的Stop The World是可控制的（G1将内存分为多个Region）

**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![CMS 垃圾收集器 ](https://gitee.com/SnailClimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

#### G1垃圾收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 垃圾回收是否有内存泄漏的风险

[ThreadLocal原理及内存泄露预防](https://blog.csdn.net/puppylpg/article/details/80433271)

#### 强引用、弱引用、软引用、虚引用
[理解Java的强引用、软引用、弱引用和虚引用](https://juejin.im/post/5b82c02df265da436152f5ad#heading-4)

引用类型 | GC回收 | 用途 | 生存时间
---|---|---|---|---
强引用 | 从来不会 | 对象的一般状态 | JVM停止运行时终止
软引用 | 当内存不足时 | 对象缓存 | 内存不足时终止
弱引用 | 正常垃圾回收时 | 对象缓存 | 垃圾回收后终止
虚引用 | 正常垃圾回收时 | 跟踪对象的垃圾回收 | 垃圾回收后终止

1. 强引用：StrongReference，使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它
   
    ```java
    Object strongReference = new Object();
    ```
    
2. 软引用：SoftReference，如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存
   
    ```java
    // 强引用
    String strongReference = new String("abc");
    // 软引用
    String str = new String("abc");
    SoftReference<String> softReference = new SoftReference<String>(str);
    ```
    
3. 弱引用：WeakReference，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象
   
    ```java
    String str = new String("abc");
    WeakReference<String> weakReference = new WeakReference<>(str);
    str = null;
    ```
    
4. 虚引用：PhantomReference，虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动

    虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

    ```java
    String str = new String("abc");
    ReferenceQueue queue = new ReferenceQueue();
    // 创建虚引用，要求必须与一个引用队列关联
    PhantomReference pr = new PhantomReference(str, queue);
    ```

#### GC调优策略

**策略 1：** 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

**策略 2：** 大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。`-XX:PretenureSizeThreshold` 可以设置直接进入老年代的对象大小。

**策略 3：** 合理设置进入老年代对象的年龄，`-XX:MaxTenuringThreshold` 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。

**策略 4：** 设置稳定的堆大小，堆大小设置有两个参数：`-Xms` 初始化堆大小，`-Xmx` 最大堆大小。

**策略5：** 注意： 如果满足下面的指标，**则一般不需要进行 GC 优化：**

> MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。

### 3.3 HotSpot 虚拟机对象

1. **对象的创建过程**

   ![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/8B831B370092496A8A3E21A22CC88A1B/11724)

   **Step1:类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

   **Step2:分配内存**：**分配方式**有 **“指针碰撞”** （堆规整的情况）和 **“空闲列表”**（堆不规整的情况） 两种

   虚拟机采用两种方式来保证创建对象时的线程安全：

   - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
   - **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

   **Step3:初始化零值：**内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）

   **Step4:设置对象头**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

   **Step5:执行 init 方法**：一般来说，执行 new 指令之后会接着执行 `<init>` 方法，这样一个真正可用的对象才算完全产生出来

2. **对象的内存布局**

   对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**

   **对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针

   **实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容

   **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用**

3. **对象的访问定位**

   建立对象就是为了使用对象， Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

   1. **句柄：**如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
   2. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

   **使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

### 3.4 类加载机制

#### 解释ClassLoader，类加载器有几种，类加载器加载顺序
*《深入理解Java虚拟机》P227 7.4*
1. 类加载器用于实现类的加载动作，它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
2. Java自带的三种类加载器：

    加载器 | 名称 | 加载目录
    ---|---|---
    ClassLoader | BootStrap启动类加载器 | <JAVA_HOME>/lib
    ExtClassLoader | 扩展类加载器 | <JAVA_HOME>/lib/ext
    AppClassLoader | 应用程序类加载器 | java -classpath

3. 双亲委派模式：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载

    <img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/9B449FCD76974551A97D9A6AFA0975B3/5557" alt="image" style="zoom:67%;" />
    
    双亲委派模式的好处：
    1. 避免类的重复加载
    2. 避免java核心api被串改（如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，可以正常编译，但永远无法被加载运行）


#### 哪个框架破坏了双亲委派模式
*《深入理解Java虚拟机》P233*

典型的打破双亲委派模型的框架和中间件有tomcat与osgi
1. 第一次“被破坏”：发生在双亲委派模型出现之前，即JDK 1.2发布之前。由于双亲委派模型在JDK 1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK 1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协
2. 第二次“被破坏”：由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，可能存在基础类又要调用回用户的代码。为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器
3. 第三次“被破坏”：由于用户对程序动态性的追求而导致的。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，的类查找可能是在平级的类加载器中进行

#### 类的生命周期（类加载过程）
*《深入理解Java虚拟机》P214 7.3*

类的加载：将编译好的class类文件中的字节码读入到内存中，将其放在方法区内创建对应的class对象，类的加载分为：加载、验证、准备、解析、初始化。加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的。

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/F5D9C6FC016743B491D80D4310F63989/5559)

1. 加载：
    1. 通过一个类的全限定名来获取定义此类的二进制字节流
    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
    > 注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从j包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）
2. 验证：重要但不一定必要（对程序运行期没有影响），若所运行的全部代码都已经被反复使用和验证过，那么在实施阶段可关闭类验证，缩短虚拟机类加载的时间。完成四个阶段的检验动作：
    1. 文件格式（通过文件格式验证后，字节流进入内存的方法区中进行存储）
    2. 元数据（检查类）
    3. 字节码（检查方法体）
    4. 符号引用
3. 准备：在方法区中为类变量（被static修饰的变量，不包含final修饰的变量，final修饰的变量在编译时就已分配赋值）分配内存并设置类变量初始值（零值），而非代码中的具体值（代码中值的赋值将在初始化阶段执行）
4. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。虚拟机规范之中并未规定解析阶段发生的具体时间，执行前解析即可
5. 初始化：真正开始执行类中定义的Java程序代码（或者说是字节码），根据程序员通过程序制定的主观计划去初始化类变量和其他资源。有且仅有以下五种情况，如果类没有初始化则会先触发其初始化：
    1. 遇到new、getstatic、setstatic或者invokestatic这4个字节码指令时：使用new关键字实例化对象；读取或设置一个类的静态字段（final修饰的字段除外）；调用一个类的静态方法
    2. 使用java.lang.reflect包的方法对类进行反射调用的时
    3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
    4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类
    5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化


#### 编译生成的class存放在哪
类的加载的过程中，加载并通过通过文件格式验证后（验证的第一步），会将编译好的class类文件中的字节码读入到内存中，并将其放在方法区内

#### `A a = new A()`的执行过程，内存分配的方式
虚拟机遇到一条`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查代表这个符号引用的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载。

在类加载检查通过后，接下来虚拟机将会为新生的对象分配内存。对象所需的内存大小在类加载完成后就可以确定，为对象分配空间的任务等同于把一块大小确定的内存从Java堆中划分出来。内存分配有两种方式：

1. 指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。分配内存时就把指针向空闲空间那边挪动一段与对象大小相等的距离。一些新生代GC收集器使用的是复制算法，所以采用指针碰撞方式分配内存
2. 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录。老年代垃圾收集器使用了标记清理、整理算法，所以配合空闲列表方式分配内存

## 4 框架
深入分析Java Web技术内幕（1、2、5-11章）
### 4.1 Spring、Spring Boot
#### 为什么要用Spring框架开发
*《Spring 3.x》P5 1.3*
1. 方便解耦，简化开发：通过IoC容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用
2. AOP编程的支持：通过Spring提供的AOP功能，方便进行面向切面的编程，许多不易用传统OOP实现的功能可以通过AOP实现
3. 声明事物的支持：通过声明式方式灵活地进行事务的管理，提高开发效率和质量
4. 方便程序的测试：可以用非容器依赖的编程方式进行几乎所有的测试工作，让测试更方便。例如：可以用Junit4通过注解方便的测试
5. 方便集成各种优秀框架：降低各种框架的使用难度，Spring提供了对各种优秀框架的直接支持（如Struts,Hibernate、Hessian、Quartz）
6. 降低Java EE API的使用难度：对很多难用的Java EE API（如JDBC，JavaMail，远程调用）提供了封装层，降低其使用难度
7. 源码是经典学习范例：Spring的源码设计精妙、结构清晰，体现着对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码是Java技术的最佳实践范例

#### IoC AOP 理解
*《Spring 3.x》P41 3.1 & 《Spring 3.x》P174 6.1*

Spring最成功的是其提出的理念，而不是技术本身。它所依赖的两个核心理念，一个是控制反转（IoC），另一个是面向切面编程（AOP）
1. IoC：Spring容器的内核，AOP、声明式事务等功都以此为基础。它涉及代码解耦、设计模式、代码优化等问题的考量。
   
    某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。也就是“依赖注入”，让调用类对某一接口实现类的依赖关系有第三方注入，以移除调用类对某一接口实现类的依赖
    1. IoC的类型（Spring支持构造函数注入和属性注入）：
        1. 构造函数注入：在构造函数注入中，我们通过调用类的构造函数，将接口实现类通过构造函数变量传入
        2. 属性注入：属性注入可以有选择地通过Setter方法完成调用类所需依赖的注入，更加灵活方便
        3. 接口注入： 将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法。由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，因此我们不提倡采用这种方式
    2. 通过容器完成依赖关系的注入：用一个第三方的容器（Spring）帮助完成类的初始化与装配工作，完成底层实现类的实例化、依赖关系装配等工作。Spring通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作
2. AOP：面向切面编程，作为OOP的有益补充，AOP的应用场合有限制，它一般只使用与那些具有横切逻辑的应用场合：如性能检测，访问控制，事物管理以及日志记录。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类：
    1. 静态代理是指使用AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也称为编译时增强（AspectJ）
    2. 动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强（Spring AOP）

#### AOP的使用场景
[AOP的应用场景(异常处理、安全检查和缓存)](https://blog.csdn.net/lzufeng/article/details/89816281)

[Principle of Spring AOP Implementation](https://programmer.help/blogs/principle-of-spring-aop-implementation.html)

1. 异常处理
2. 安全检查
3. 缓存

#### 什么是动态代理和静态代理
1. 静态代理是指使用AOP框架提供的命令进行编译，从而在编译阶段就可生成AOP代理类，因此也称为编译时增强（AspectJ）
2. 动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类，因此也被称为运行时增强（Spring AOP）

#### 静态代理和动态代理的优缺点
1. 静态代理
    1. 优点：静态代理对客户端隐藏了被代理类接口（目标类接口）的具体实现类，在一定程度上实现了解耦合，同时提高了安全性
    2. 缺点：
        1. 静态代理类需要实现目标类（被代理类）的接口，并实现其方法，造成了代码的大量冗余
        2. 静态代理只能对某个固定接口的实现类进行代理服务，其灵活性不强。故一般大项目不会选择静态代理
2. 动态代理
    1. 优点：
        1. 动态代理实现了只需要将被代理对象作为参数传入代理类就可以获取代理类对象，从而实现类代理，具有较强的灵活性
        2. 动态代理的服务内容不需要像静态代理一样写在每个代码块中，只需要写在`invoke()`方法中即可，降低了代码的冗余度
    2. 缺点：JDK动态代理基于接口，需要被代理客户端实现接口；CGLib动态代理基于继承，final类无法代理

#### 动态代理的实现
*《Spring 3.x》P181 6.2.2 & 《Spring 3.x》P184 6.2.3*
1. JDK动态代理：基于接口的代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。核心是InvocationHandler接口和Proxy类，具体实现原理：
    1. 实现`InvocationHandler`接口创建自己的编织器。重写`invoke()`方法，反射机制调用业务类的目标方法
    2. 实例化一个编织器`handler`。通过构造方法传入希望被代理的目标对象
    3. 实例化`Proxy`类。通过静态方法`newProxyInstance()`为编织了业务逻辑和增强逻辑的`handler`创建一个符合业务类接口的代理实例
2. CGLIB动态代理：基于继承的代理。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。采用非常底层的字节码技术：
    1. 实现`MethodInterceptor`接口创建代理创建器`CglibProxy`
        1. 实现`getProxy()`方法。设置需要创建子类的类（业务类），通过字节码技术动态创建子类实例
        2. 实现`intercapt()`方法。拦截父类所有方法的调用，通过代理类调用父类中的方法
    2. 实例化一个代理创建器`proxy`。通过动态生成子类的方法（`getProxy()`）创建代理类

    关于两者之间的性能：
    1. CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍
    2. 但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距
    3. 因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则比较适用JDK动态代理

#### Spring bean生命周期
> Spring 只帮我们管理单例模式 Bean 的**完整**生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。

[描述Spring Bean 的生命周期](https://zhuanlan.zhihu.com/p/108198655)

<img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/0A3BCB892FD4403F91C3CA32FCFFD75C/9445" alt="image" style="zoom:67%;" />

[Spring中Bean的生命周期及其扩展点](https://www.cnblogs.com/V1haoge/p/6106456.html)


![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/DBCB7B1D584841279457853CEA5AC98C/5561)

1. BeanFactoryPostProcessor的postProcessorBeanFactory()方法：若某个IoC容器内添加了实现了BeanFactoryPostProcessor接口的实现类Bean，那么在该容器中实例化任何其他Bean之前可以回调该Bean中的postPrcessorBeanFactory()方法来对Bean的配置元数据进行更改，比如从XML配置文件中获取到的配置信息。
2. Bean的实例化：Bean的实例化是使用反射实现的。
3. Bean属性注入：Bean实例化完成后，利用反射技术实现属性及依赖Bean的注入。
4. BeanNameAware的setBeanName()方法：如果某个Bean实现了BeanNameAware接口，那么Spring将会将Bean实例的ID传递给setBeanName()方法，在Bean类中新增一个beanName字段，并实现setBeanName()方法。
5. BeanFactoryAware的setBeanFactory()方法：如果某个Bean实现了BeanFactoryAware接口，那么Spring将会将创建Bean的BeanFactory传递给setBeanFactory()方法，在Bean类中新增了一个beanFactory字段用来保存BeanFactory的值，并实现setBeanFactory()方法。
6. ApplicationContextAware的setApplicationContext()方法：如果某个Bean实现了ApplicationContextAware接口，那么Spring将会将该Bean所在的上下文环境ApplicationContext传递给setApplicationContext()方法，在Bean类中新增一个ApplicationContext字段用来保存ApplicationContext的值，并实现setApplicationContext()方法。
7. BeanPostProcessor预初始化方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后，执行初始化之前会调用BeanPostProcessor中的postProcessBeforeInitialization()方法执行预初始化处理。
8. InitializingBean的afterPropertiesSet()方法：如果Bean实现了InitializingBean接口，那么Bean在实例化完成后将会执行接口中的afterPropertiesSet()方法来进行初始化。
9. 自定义的inti-method指定的方法：如果配置文件中使用init-method属性指定了初始化方法，那么Bean在实例化完成后将会调用该属性指定的初始化方法进行Bean的初始化。
10. BeanPostProcessor初始化后方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后并且完成初始化调用后执行该接口中的postProcessorAfterInitialization()方法进行初始化后处理。
11. 使用Bean：此时有关Bean的所有准备工作均已完成，Bean可以被程序使用了，它们将会一直驻留在应用上下文中，直到该上下文环境被销毁。
12. DisposableBean的destory()方法：如果Bean实现了DisposableBean接口，Spring将会在Bean实例销毁之前调用该接口的destory()方法，来完成一些销毁之前的处理工作。
13. 自定义的destory-method指定的方法：如果在配置文件中使用destory-method指定了销毁方法，那么在Bean实例销毁之前会调用该指定的方法完成一些销毁之前的处理工作。

注意：
1. BeanFactoryPostProcessor接口与BeanPostProcessor接口的作用范围是整个上下文环境中，使用方法是单独新增一个类来实现这些接口，那么在处理其他Bean的某些时刻就会回调响应的接口中的方法。
2. BeanNameAware、BeanFactoryAware、ApplicationContextAware的作用范围的Bean范围，即仅仅对实现了该接口的指定Bean有效，所有其使用方法是在要使用该功能的Bean自己来实现该接口。
3. 第8点与第9点所述的两个初始化方法作用是一样的，我们完全可以使用其中的一种即可，一般情况我们使用第9点所述的方式，尽量少的去来Bean中实现某些接口，保持其独立性，低耦合性，尽量不要与Spring代码耦合在一起。第12和第13也是如此。

#### Spring Boot的starter机制

1. 起步依赖

   - 引入starter中的相关jar包，其中

     > spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，
     >
     > mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。
     >
     > spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。
     
   - 根据application.properties配置数据源

2. 自动配置

   1. 基于java代码的bean配置 -> @Configuration&与@Bean

      > @Configuration注解的类可以看作是能生产让Spring IoC容器管理的Bean实例的工厂
      > @Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到Spring容器中

   2. 设置自动配置条件依赖 -> @Conditional

   3. Bean参数的获取 -> @EnableConfigurationProperties与@ConfigurationProperties

      > @ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。
      >
      > @EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。

   4. Bean的发现与加载 -> @EnableAutoConfiguration、@AutoConfigurationPackage与@Import

      springboot默认扫描启动类所在的包下的主类与子类的所有组件

      > @Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。
      >
      > @ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。
      >
      > @EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。

      如果要让一个普通类交给Spring容器管理，通常有以下方法：

      > - 使用 @Configuration与@Bean 注解
      > - 使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描
      > - 使用@Import 方法

### 4.2 Mybatis
#### mybatis $#的区别，为什么#可以防止注入
https://www.cnblogs.com/wslook/p/9185448.html

动态SQL是mybatis的强大特性之一。在动态SQL解析阶段，`#{ }`和`${ }`会有不同的表现
1. 解析方式不同：
    1. `#{ }`解析为一个JDBC预编译语句（Prepare Statment）的参数占位符。传入的参数在SQL中显示为字符串，会对传入的数据加引号。例：
        ```sql
        select id,name,age from student where id =#{id}
        // 当传递的参数id为"1"时，解析为
        select id,name,age from student where id ='1'
        ```
    2. `${ }`在动态SQL解析阶段进行变量替换，然后再进行预编译。传入的参数在SQL中直接显示为传入的值。例：
        ```sql
        select id,name,age from student where id =${id}
        // 当我们传递的参数id为"1"时，解析为
        select id,name,age from student where id =1
        ```
2. 安全性：
    1. `#{ }`可以防止SQL注入的风险：MyBatis默认启用了预编译功能，在SQL执行前，先将SQL发送给数据库进行编译，此时`#{ }`解析为一个JDBC预编译语句的参数占位符；执行时，替换编译好的SQL中的占位符。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题
    2. `${ }`无法防止Sql注入在MyBatis中：`${ }`这样的参数直接参与SQL编译，从而不能避免注入攻击
3. 一般能用`#{ }`的就不用`${ }`；但有些情况下必须使用`${ }`：传入数据库对象（表名、字段名）

#### ==mybatis的resultmap如何映射，复杂的result类如何序列化==
《MyBatis》技术内幕 P236

ResultSetHandler

## 5 数据库
### 5.1 事务
#### 事务的特性
1. 一致性：Consistency，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作

   > **一致性**是事务是个特性中最重要的，由原子性、隔离性、持久性来保证

2. 原子性：Atomicity，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样

   > 原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。

3. 隔离性：Isolation，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读提交、可重复读和串行化

   > 隔离性由 MVCC 和 Lock 保证

4. 持续性/永久性：Durability，事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

   >持久性由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。

#### 事务隔离级别和可能遇到的问题
隔离级别\问题 | 脏读 | 不可重复读 | 幻读
---|---|---|---
读未提交（read uncommitted） | √可能 | √可能 | √可能 
读已提交（read commited） | ×不可能 |√可能  | √可能 
可重复读（repeatable read） | ×不可能 | ×不可能 | √可能 
串行化 | ×不可能 |×不可能 |×不可能

1. 事务隔离级别
    1. 读未提交：Read Uncommitted，有可能出现脏读，也就是可能读取到其他会话中未提交事务修改的数据
    2. 读已提交：Read Committed，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别
    3. 可重复读：Repeatable Read，在同一个事务内的查询都是与事务开始时刻一致的。InnoDB默认级别
    4. 串行化：Serializable，完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
2. 可能产生的问题
    1. 脏读：Dirty Read，脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据
    2. 不可重复读：NonRepeatable Read，是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读
    3. 幻读：Phantom Read，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样
    
    >关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 MySQL 的优化，MySQL 的 RR 级别不会导致幻读：在使用默认的 select 时，MySQL 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。

#### 事务隔离的实现与MVCC（多版本并发控制）

MVCC通过undolog实现。可以认为是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值，而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在undolog（回滚日志）里面就会有类似下面的记录，该记录是链表式的。

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，**同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）**。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

系统会判断，当没有事务再需要用到这些undolog时，undolog会被删除。

MySQL的事务启动方式有以下几种：

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。
3. Spring Boot中可以使用@Transactional注解实现

<img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/C1A35589A51141FA959649AFC679CAE1/9451" alt="image" style="zoom:50%;" />



#### ==分布式情况下如何保证事务==




### 5.2 索引
#### MySQL索引类别
[MySQL索引类型](https://www.cnblogs.com/luyucheng/p/6289714.html)

```sql
CREATE TABLE table_name[col_name data type]
[unique|fulltext][index|key][index_name](col_name[length])[asc|desc]
```
> 1. `unique` `fulltext`为可选参数，分别表示唯一索引、全文索引
> 2. `index` `key`为同义词，两者作用相同，用来指定创建索引
> 3. `col_name`为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择
> 4. `index_name`指定索引的名称，为可选参数，如果不指定，默认`col_name`为索引值
> 5. `length`为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度
> 6. `asc` `desc`指定升序或降序的索引值存储

> 索引存储在存储引擎中

1. 普通索引：最基本的索引，它没有任何限制

2. 唯一索引：与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一

3. 主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引

4. 组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合

5. 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较

    > `fulltext`索引跟其它索引不同，它更像是一个搜索引擎。`fulltext`索引配合`match against`操作使用，而不是一般的`where`语句加`like`。它可以在`create table`，`alter table`，`create index`使用，不过目前只有`char` `varchar` `text` 列上可以创建全文索引。在数据量较大时候，先将数据放入一个没有全局索引的表中，然后再用`CREATE index`创建`fulltext`索引，要比先为一张表建立`fulltext`然后再将数据写入的速度快很多

#### 索引的作用
1. 快速取数据（大大加快数据的检索速度）
2. 保证数据记录的唯一性（创建唯一性索引，保证数据库表中每一行数据的唯一性）
3. 实现表与表之间的参照完整性（加速表和表之间的连接）
4. 在使用`ORDER BY` `GROUP BY`子句进行数据检索时，利用索引可以减少排序和分组的时间（在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间）

#### 索引数据结构，为什么用B+树而不是而不是B树，两者有什么区别
https://blog.csdn.net/u013411246/article/details/81088914
1. B树
    1. B-tree树即B树，B即Balanced。一种多路搜索树（并不是二叉的）
        1. 定义任意非叶子结点最多只有M个儿子；且M>2；
        2. 根结点的儿子数为[2, M]；
        3. 除根结点以外的非叶子结点的儿子数为[M/2, M]；
        4. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
        5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
        6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
        7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
        8. 所有叶子结点位于同一层；

        如：（M=3）
    
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/576AFC0C2B5248578CA14682B25E5121/5563)
    
        B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点
        
    2. B-树的特性
        1. 关键字集合分布在整颗树中；
        2. 任何一个关键字出现且只出现在一个结点中；
        3. 搜索有可能在非叶子结点结束；
        4. 其搜索性能等价于在关键字全集内做一次二分查找；
        5. 自动层次控制；
        
        由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/D2C65A14849640ECBB41E28537261D07/5565)
        
        其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并
2. B+树
    1. B+树是B-树的变体，也是一种多路搜索树，其定义基本与B-树同，除了：
        1. 非叶子结点的子树指针与关键字个数相同；
        2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
        3. 为所有叶子结点增加一个链指针；
        4. 所有关键字都在叶子结点出现；
    
        如：（M=3）
        
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/632EBCA1BA0742019D1BB179B0BA48BC/5567)
    
        B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；
    2. B+的特性
        1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
        2. 不可能在非叶子结点命中；
        3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
        4. 更适合文件索引系统；

[**为什么MySQL选择B+树做索引**](https://www.jianshu.com/p/7ce804f97967)
1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。
4. B+树更适合基于范围的查询：B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

#### 组合索引，查询`c>5 a=1`是否命中索引`ac`和`ca`
1. 使用组合索引时遵循最左前缀集合
2. 查询是否命中索引，和索引顺序有关，和查询顺序无关
3. 前位查询精确匹配（`=` `in` `between`）索引，后位查询才能命中索引
4. 对于字符串，采用左匹配索引，`xxx%`可命中索引，`%xxx`无法命中索引

因此，查询`c>5 a=1`时，索引`ac`会全部命中，索引`ca`只会部分命中`c`

```java
// 表t(a,b,c) 三个字段组成组合索引
select * from t where a=? and b=? and c=?  //全命中
select * from t where c=? and b=? and a=?  //全命中（MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引）
select * from t where a=?  //命中a（最左前缀匹配）
select * from t where a=? and b=?  //命中a和b（最左前缀匹配）
select * from t where a=? or b=?  //一个没命中（or无法命中）
select * from t where a=? and c=?  //命中a（最左前缀匹配，中间没有则无法使用索引）
select * from t where a=? and b in ( x, y, z) and c=?  //全部命中（in精确匹配可以使用索引）
select * from t where b=?  //一个没命中（最左前缀匹配原则）
select * from t where b=? and c=?  //一个没命中（最左前缀匹配原则）
select * from t where a=? and b like 'xxx%'  //命中a和b
select * from t where a=? and b like '%xxx'  //命中a（`%xxx`无法命中索引）
select * from t where a<? and b=?  //命中a（a为范围查找）
select * from t where a between ? and ? and b=?  //命中a和b（BETWEEN相当于in操作是精确匹配）
select * from t where a between ? and ?  and b=? and c  and between ? and ?  //全命中
select * from where a-1=?  //函数和表达式无法命中索引
```

#### 索引命中后的查找对应行的过程
[MySQL优化：如何避免回表查询？什么是索引覆盖？](https://www.cnblogs.com/myseries/p/11265849.html)

> InnoDB有两大类索引，聚集索引（clustered index）、普通索引（secondary index）。InnoDB普通索引的叶子节点存储主键值。InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：
> 1. 如果表定义了PK，则PK就是聚集索引
> 2. 如果表没有定义PK，则第一个not NULL unique列是聚集索引
> 3. 否则，InnoDB会创建一个隐藏的row-id作为聚集索引

1. 回表查询：从普通索引无法直接定位行记录，需要回表查询，先定位主键值，再定位行记录，通常情况下，需要扫码两遍索引树，性能较扫一遍索引树更低

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/BF087FC983C94B5DA0BEB35C428D11E6/5569)

2. 覆盖索引：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。常见的实现方法是：将被查询的字段，建立到联合索引里去（索引叶子节点存储了主键id）

### 5.3 锁
#### 数据库死锁是怎么造成的
*《MySQL技术内幕 InnoDB存储引擎》6.7.1*

两个或两个以上的事务在执行过程中，因争夺资源而造成的一种相互等待的现象

#### MySQL如何处理死锁
*《MySQL技术内幕 InnoDB存储引擎》6.7.1*

1. 超时机制：两个事务相互等待时，当一个等待时间超过阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行
2. 采用等待图进行死锁检测：根据数据库保存锁的信息链表和事务等待链表，得到一个有向图wait-for graph；在每个事务请求锁并发生等待时都会判断是否存在回路（环），若存在则有死锁，回滚undo量最小的事务
   
    ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/C2D6117F5A2344E8B2837608CCDA1133/5571)

#### InnoDB支持什么锁
*《MySQL技术内幕 InnoDB存储引擎》6.3.1*

1. 行级锁：InnoDB存储引擎实现了两种标准的行级锁：
    1. 共享锁（S Lock）：允许事务读一行数据
    2. 排他锁（X Lock）：允许事务删除或更新一行数据
2. 意向锁：InnoDB存储引擎支持多粒度锁定，允许事务在行级锁和表级锁同时存在。为了支持在不同粒度上进行加锁，InnoDB存储引擎支持意向锁，即为表级别的锁，两种意向锁：
    1. 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁
    2. 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁

兼容性 | IS | IX | S | X
---|---|---|---|---
IS | 兼容 | 兼容 | 兼容 | 不兼容
IX | 兼容 | 兼容 | 不兼容 | 不兼容
S | 兼容 | 不兼容 | 兼容 | 不兼容
X | 不兼容 | 不兼容 | 不兼容 | 不兼容

由于InnoDB存储引擎支持的是行级锁，因此意向锁不会阻塞除全表扫以外的任何请求

**InnoDB有三种行锁的算法：**

1. Record Lock：单个行记录上的锁。

2. Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

3. Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题

### 5.4 引擎
#### MySQL引擎类别
<img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/ADF5170BBF0643B58BDE6BC171DAF088/5573" alt="image" style="zoom:50%;" />

索引类别 | 事务安全 | 锁 | 其他说明 |应用
---|---|---|---|---|---
MyISAM存储引擎 | 不支持 | 表级锁 | 不能在表损坏后恢复数据 | 做很多count的计算；查询非常频繁
InnoDB存储引擎 | 支持 | 行级锁 | 仅此引擎支持外键 | 更新和查询频繁，多重并发；要求事务，或可靠性要求高；外键约束
MEMORY（HEAP）引擎| 不支持 | 表级锁 | 仅支持长度不变的数据类型 | 内存中存储数据，非常高速
ARCHIVE引擎 | 不支持 | 行级锁和专用的缓存区 | 支持最基本的插入和查询。MySQL 5.5支持索引 | 适合存储大量日志、历史数据
BLACKHOLE引擎 | 支持 | 持mvcc的行级锁 | | |
CSV引擎 | | | 不支持索引，主键列，不允许表中的字段为null| 

1. MyISAM存储引擎

    默认的存储引擎，提供高速存储和检索，以及全文搜索能力。每个表会生成三个文件(文件名就是表名)：.frm 表结构；.MYD 数据；.MYI 索引
    1. 不支持事务。表级锁。不能在表损坏后恢复数据
    2. 适合在以下几种情况下使用：
        1. 做很多count的计算
        2. 查询非常频繁
2. InnoDB存储引擎
   
    具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此表上的索引较多的话，主键应当尽可能的小。一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择
    1. 支持事务和外键。行级锁
    2. 适合在以下几种情况下使用：
        1. 更新和查询都相当的频繁，多重并发
        2. 要求事务，或者可靠性要求比较高
        3. 外键约束，MySQL支持外键的存储引擎只有InnoDB
3. MEMORY（HEAP）引擎
   
    数据保存在内存中，拥有极高的插入、更新和查询效率。但是不稳定，重启以后数据都会丢失。每个表会生成一个.frm文件，该文件只存储表的结构
    1. 不支持事务。支持表级锁，因此并发写入的性能较低。支持长度不变的数据类型，不支持BLOB或TEXT长度可变的数据类型。VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。支持HASH索引和B-Tree索引，默认使用HASH索引。
    2. 内存中存储数据，非常高速。mysql关闭后所有数据消失，mysql启动时会创建空表

    > B-Tree索引的优于HASH索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。HASH索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此HASH索引值适合使用在`=`和`<>`的操作符中，不适合在`<`或`>`操作符中，也同样不适合用在`order by`子句中。在内存中存放数据，所以会造成内存的使用，可以通过参数`max_heap_table_size`控制MEMORY表的大小
    
4. ARCHIVE引擎
   
    拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩。支持最基本的插入和查询两种功能。在MySQL 5.5开始支持索引。
    1. 不支持事务。支持行级锁和专用的缓存区，所以可以实现高并发的插入
    2. 适合存储大量日志、历史数据
5. BLACKHOLE引擎
   
    接受但不存储数据，但是如果MySQL启用了二进制日志，SQL语句被写入日志（并被复制到从服务器）。用于做日志记录或同步归档的中继存储。但这种应用方式会碰到很多问题，因此并不推荐。
    
    1. 支持事务，而且支持mvcc的行级锁
6. CSV引擎
   
    每个表会生成一个.CSV文件，将CSV类型的文件当做表进行处理。把数据以逗号分隔的格式存储在文本文件中，这种文件是一种普通文本文件，每个数据行占用一个文本行。
    
    1. 不支持索引，即使用该种类型的表没有主键列，也不允许表中的字段为null

### 5.5 日志

#### ==`redolog`、`binlog`、`undolog`==

1. redolog

   MySQL中的redolog使用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。**redo log是InnoDB引擎特有的日志**。

   redo log称为重做日志，每当有操作时，在数据变更之前将操作写入redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。

   具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

   InnoDB的redo log是固定大小的。比如可以配置为一组4个文件，每个文件的大小是1GB，那么redolog总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写。

   <img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/A1A4A3EF177F463EBAE0A503AAED32CA/9447" alt="image" style="zoom:50%;" />

   write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。

   checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

   如果write pos追上checkpoint，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。

2. binlog

   binlog是Server层的日志（归档日志）。

   redolog与binlog的异同：

   1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
   2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
   3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

3. undolog

   undo log称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。

4. 两阶段提交

   update语句执行的过程中，redo log和bin log使用了两阶段提交来保证两份日志之间的逻辑一致。

   redo log的写入拆成了两个步骤：prepare和commit，这就是"两阶段提交"。

   <img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/76B5C5A109864DC2A09A0609CAEDB1A4/9449" style="zoom:50%;" />

### 5.6 SQL优化

#### ==SQL调优思路==

1.索引的建立

2.sql的书写

3.覆盖索引

4.MySQL其它原因，随机采样

#### 慢SQL如何排查，会引起什么问题

#### limit为什么慢
[mysql优化之limit优化](https://zhuanlan.zhihu.com/p/29090098)

limit扫描的额外行数过多，因此效率低
1. 直接`limit`查询：将扫描全表
   
    ```sql
    select * from actor limit 1,1;
    ```

2. 加上合适的`order by`：扫描目标行及目标行以前的所有行
   
    ```sql
    select * from actor order by actor_id limit 10,1;
    ```

#### 优化SQL `select * from t limit 1,100`
*《高性能MySQL》6.7.5*

1. 避免请求不必要的数据：避免`select *`的写法
2. 将`limit`替换为已知位置的查询：使用`where`

    ```sql
    select id, name from t where position between 10 and 20;
    ```

3. 避免使用`offset`：（高效率实现上下翻页）
   
    ```sql
    // 查询第一页
    select * from t order by position desc limit 20;
    // 查询结果为 position 1020到1001的记录，则查询下一页
    select * from t where position < 1001 order by position desc limit 20;
    ```

#### 数据库设计中遇到的问题
1. wl case：时间排序，会有相同时间情况。用多参数排序
2. 大表翻页

## 6 计算机网络
### 6.1 网络基础
#### 长连接和短连接
1. 短连接：连接->传输数据->关闭连接。比如：HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接
2. 长连接：连接->传输数据->保持连接->传输数据->……->直到一方关闭连接（多是客户端关闭连接），长连接建立SOCKET连接后不管是否使用都保持连接，但安全性较差。比如：数据库的连接用长连接

#### ==`get`和`post`区别==

#### ==`session`与`cookie`区别==

#### 从在浏览器输入网址到返回页面，经历了什么
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

### 6.2 TCP协议
#### TCP协议为什么是三次握手，两次为什么不可以
TCP 是可靠通信协议：接收方收到的数据是完整、有序、无差错的。

为了实现可靠传输，发送方和接收方始终需要同步（SYNchronize）序号。 需要注意的是，序号并不是从 0 开始的，而是由发送方随机选择的初始序列号（Initial Sequence Number, ISN）开始。由于TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。因此，为了建立双向连接，通信双方都需要随机产生一个初始的序列号， 并且把这个起始值告诉对方。

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/EDCA7A4737B2420DB49927A98CBB621E/5575)

#### ==TCP链接通道里有什么，报文包含什么内容==
[TCP报文格式详解](https://blog.csdn.net/mary19920410/article/details/58030147)

#### TCP可靠传输（如果传输中丢失了报文如何处理）
*《计算机网络—自顶向下方法》3.5.4*

简化的TCP发送方有3个与发送和重传有关的主要事件：
1. 从上层接收数据：TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。每个报文段都包含一个序号，及报文段第一个数据字节的字节流编号。如果定时器还没有为某些其他报文段运行，则当报文段传给IP时，TCP就启动该定时器，间隔为TimeoutInterval
2. 定时器超时：TCP通过重传引起超时的报文段来响应超时事件。然后TCP重启定时器
3. 收到ACK：TCP将ACK的值y与它的变量SendBase进行比较。SendBase是最早未被确认的字节的序号。TCP采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果y>SendBase，则该ACK是在确认一个或多个先前未被确认的报文段。因此发送方更新它的SendBase变量；如果当前有未被确认的报文段，TCP还要重新启动定时器

#### TCP流量控制（如果发送方的速率高于接收方，如何避免接收缓存溢出）
*《计算机网络—自顶向下方法》3.5.5*

TCP为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配

流量控制的实现：TCP通过让发送方维护一个称为接收窗口的变量（TCP报文段首部的接收窗口字段）来提供流量控制。通俗的讲，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护了一个接收窗口

#### TCP连接，其中一端断电会如何
1. TCP连接双方定时发握手消息
2. 利用TCP协议栈中的KeepAlive探测

#### 能ping通的两台机器是否一定能通过TCP连接能成功
不一定
1. ping命令使用ICMP协议：Internet控制报文协议，是TCP/IP协议簇的一个子协议，属于网络层协议。用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息
   
    > ping用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。它发送ICMP回送请求消息给目的主机，ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达

2. TCP：传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议

## 7 操作系统
### 7.1 进程与线程
#### 线程进程的区别（资源、通信）
1. 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行
2. 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理

线程和进程区别和优劣：
1. 进程是资源分配的最小单位，线程是程序执行的最小单位。
2. 地址空间：
    1. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。多进程程序更健壮，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间
    2. 线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。多线程程序只要有一个线程死掉，整个进程也死掉了
3. 通信
    1. 进程之间的通信需要以通信的方式（IPC）进行。不过如何处理好同步与互斥是编写多线程程序的难点。
    2. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据

单线程与多线程：
1. 单线程（单个cpu等运行）：比如，打开任意一个浏览器，里面有多个标签页；当某一个标签页系统崩溃时，其他标签页也不能使用，必须关掉浏览器。
2. 多线程（多个cpu等运行）：比如，浏览器中有多个标签页，当某一个标签页系统崩溃时，只是该标签页不能使用，不影响其他标签页的正常使用。

#### 线程有几种状态
线程的五种状态：新建状态、就绪状态、运行状态、阻塞状态及死亡状态

### 7.2 死锁
#### 多线程死锁
[用个通俗的例子讲一讲死锁](https://zhuanlan.zhihu.com/p/26945588)
1. 死锁的定义

    死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进
2. 系统资源的竞争
    1. 竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
    2. 竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
3. 死锁产生的必要条件：死锁发生时，四个条件必须同时满足，其中任意一个不成立，死锁就不会发生
    1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放（只有一副钥匙）
    2. 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放（拿着红钥匙的人在没有归还红钥匙的情况下，又提出要蓝钥匙）
    3. 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放（除非归还了钥匙，不然一直占用着钥匙）
    4. 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源（拿着红钥匙的人在等蓝钥匙，同时那个拿着蓝钥匙的人在等红钥匙）
4. 避免死锁

    要避免出现死锁的问题，只需要破坏四个条件中的任何一个就可以了
    1. 破坏互斥条件
    
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/356D2DB6C7734FFE9CEDD76ECEEF2104/5577)
        
        只有一副钥匙，这是形成死锁的最关键的原因。显然，如果我们能在两个线程跑之前，能给每个线程单独拷贝一份钥匙的副本，就能有效的避免死锁了。当然，这种方法试用范围并不广。因为有时如果系统拷贝那副钥匙的成本极高，而线程又很多的话，这种方法就不适用了
    2. 破坏请求和保持条件
    
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/4921DB3C6E9547C1AD98B2BEC3B4005A/5579)
        
        任何一个线程“贪心”，都可能会导致死锁。大致就是说有了一把钥匙还没还就要另一把。这里我们可以通过规定在任何情况下，一个线程获取一把钥匙之后，必须归还了钥匙之后才能请求另一把钥匙，就可以有效解决这个问题
    3. 破坏不剥夺条件
    
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/BE6E66818C524E2D9FBB232FB2F1CB65/5581)
        
        除非线程自己还钥匙，否则线程会一直占有钥匙，是形成不可剥夺条件的原因。这里，我们可以通过设置“最长占用时间“的阈值来解决这个问题——如果过了10分钟仍然没有进入下一个步骤，则归还已有的钥匙。这样的话，两个线程都能取到所需的钥匙继续下去了
    4. 破坏环路等待条件
    
        ![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/761AF41444B947E48EB852DC40B8205E/5583)
        
        会出现死锁的两两组合，一定都是一个线程先取了红钥匙而另一个线程先取了蓝钥匙，从而导致了可能形成了“环路等待”。所以我们可以强制规定任何线程取钥匙的顺序只能是 “先取蓝钥匙再取红钥匙”的话，就能避免死锁了

#### 银行家算法
[操作系统：银行家算法（避免死锁）](https://blog.csdn.net/s634772208/article/details/46324257)

### 7.3 存储管理
#### ==分页算法，FIFO、LRU==
1. FIFO：先进先出页面置换算法
2. LRU：Least Recently Used 最近最少使用算法

## 8 数据结构与算法
### 8.1 数据结构
#### 了解的数据结构
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/E579C02CF3364ED4B6CF8C2B3F187073/5585)

#### 红黑树插入元素的过程（变色）
[红黑树 性质及操作 维基百科](https://wikipedia.hk.wjbk.site/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)

红黑树是每个节点都带有颜色属性的二叉查找树（自平衡的查找树），颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求（保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍）：
1. 节点是红色或黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NIL节点）
4. 每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

#### Java在哪里引入了红黑树
`TreeMap` `HashMap`

#### 为什么要引入红黑树
1. 红黑树是一个平衡二叉查找树，够以O(lgn)的时间复杂度进行搜索、插入、删除操作
2. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单

#### 红黑树的查找的时间复杂度
```math
O(lgn) = O(log_2n)
```

#### 队列和栈的区别
1. 队列：先进先出
2. 栈：先进后出

### 8.2 算法
#### 常见排序算法
![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/C09578E566EB4A7C904CCFA3C2A11414/5587)

#### 一句话描述动态规划，举一个生活中的例子
1. 求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。这就是DP（动态规划，dynamic programming）
2. 生活问题

    假设一个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在的目标是凑出某个金额w，需要用到尽量少的钞票。长期的生活经验表明，贪心策略是正确的。
    
    但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：15=1×11+4×1（贪心策略使用了5张钞票）；15=3×5（正确的策略，只用3张钞票）
    
    贪心策略错在了“鼠目寸光”。贪心是一种只考虑眼前情况的策略。
    
    如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质：
    
    w=15时，
    1. 如果取11，接下来就面对w=4的情况
    2. 如果取5，则接下来面对w=10的情况
    3. 如果取1，则接下来面对w=14的情况
    
    我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”
    
    用f(n)来表示“凑出n所需的最少钞票数量”。那么，
    1. 取11：cost = f(4) + 1 = 4 + 1 = 5
    2. 取5：cost = f(10) + 1 = 2 + 1 = 3
    3. 取1：cost = f(14) + 1 = 4 + 1 = 5  
    
    `f(n)`只与`f(n - 1)` `f(n - 5)` `f(n - 11)`相关，确切的说：`f(n) = min{f(n-1), f(n-5), f(n-11)} + 1`
    
    要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来就好了
    
    它与暴力的区别在于暴力枚举了“使用的硬币”，然而这属于冗余信息。要求出f(15)，只需要知道f(14),f(10),f(4)的值。其他信息并不需要。舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).　　
    
    我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。这就是DP（动态规划，dynamic programming）

#### ==栈的最大值问题==
可以修改栈的存储方式，push，pop的操作
1. 方法1：时间复杂度`O(1)`，空间复杂度`O(n)`。一个数据栈`Sn`，一个最大值栈`Sm`
    1. `push()`方法：将元素`push`入数据栈`Sn`；当`push`入栈的元素大于/等于当前最大值栈`Sm`的栈顶元素时，将该元素`push`入最大值栈`Sm`
    2. `pop()`方法：将数据栈`Sn`栈顶元素`pop`出栈`Sn`；当`pop`出栈的元素等于最大值栈`Sm`的栈顶元素时，将最大值栈`Sm`栈顶元素`pop`出栈
    3. 最大值：`Sm`栈顶始终保存当前栈中的最大元素
2. 方法2：若能提前读入所有元素/所有元素均为非负数，则可使用本方法。时间复杂度`O(1)`，空间复杂度`O(1)`。一个数据栈`Sn`，一个最大值`max`（若可提前读入元素，则`max`的初始值为最小元素）
    1. `push()`方法：将`当前元素-max`的值`push`入栈。若当前元素大于等于`max`，将`max`的值替换为当前元素
    2. `pop()`方法：`pop`出栈顶元素。若栈顶元素为负数，则当前值为`栈顶元素+max`；若栈中元素为非负数，则当前值为`max`，并将`max`替换为`max-栈顶元素`
    3. 最大值：`max`始终保存当前栈中的最大元素

---
## 9 Linux
### 9.1 Linux命令
#### 使用 Linux命令找出日志文件中访问量最大的top10 IP地址
[使用Linux命令找出日志文件中访问量最大的top10 IP地址](https://www.cnblogs.com/zhaijing/p/9767285.html)

检验你是否熟悉Linux命令的常见问题：使用 Linux命令找出日志文件中访问量最大的top10 IP地址

日志文件test.log格式如下：

时间 IP  ****

linux 命令如下：
```shell
cat test.log|awk -F" " '{print $2}'|sort|uniq -c|sort -nrk 1 -t' '|awk -F" " '{print $2}'|head -10
```
问题剖析：

1. cat *.log将文本内容打印到屏幕
2. 使用awk命令可以按照分割符将一行分割为多个列，第一列用$1表示，第二列用$2表示，依次类推
   awk -F" " '{print $2}   //表示用空格作为分隔符进行分割，打印出第2列
3. sort 进行排序，默认是按照ascii码进行排序的
4. uniq -c 统计相邻的行的重复数量，结果是类似 3 127.13.13.13,前面的数字代码重复的行数
   sort|uniq -c  //统计重复的行数
5. sort -n是按照数值进行由小到大进行排序，
   -r是表示逆序，-t是指定分割符，-k是执行按照第几列进行排序
   sort -nrk 1 -t' '
6. 使用awk命令可以按照分割符将一行分割为多个列，第一列用$1表示，第二列用$2表示，依次类推
   awk -F" " '{print $2}'  //表示用空格作为分隔符进行分割，打印出第2列
7. head -n表示取前n个
   head -10

#### 使用Linux命令查找大文件（几个G）
1）使用grep命令查找到指定关键字所在行号：

```shell
[root@Fighter:/home/springlearning/logs]#grep -n -e "refundInterTicket" -e "2017122900237918" ws.log | head -n 3
```

该命令的解释：

1. -n参数的作用是显示查找结果的所在行号
2. -e参数表示我们需要搜索的关键字，多个关键字就用多个 -e 参数
3. ws.log表示待搜索的大日志文件
4. head -n 3 表示显示前面查询结果的前三条记录

2）使用vim命令打开文件的指定行：

vim打开文件的时候可以使用“+行号”的形式打开文件的指定行，比如我们上面查询出来的行号是27796016，因此可以使用以下命令打开文件跳转到指定行：

```shell
[root@Fighter:/home/springlearning/logs]#vim +27796016 ws.log
```

---
## 10 分布式中间件
[Java进阶知识](https://github.com/doocs/advanced-java)

### 10.1 Redis

#### Redis的应用场景

#### Redis支持的数据类型（必考）

#### zset跳表的数据结构（必考）

#### Redis的数据过期策略（必考）

#### Redis的LRU过期策略的具体实现

#### 如何解决Redis缓存雪崩，缓存穿透问题

#### Redis的持久化机制（必考）

#### Redis的管道pipeline

### 10.2 Dubbo与RPC框架

#### ==Dubbo服务暴露、引用和调用过程的基本原理==

### 10.3 Kafka与消息中间件

### 10.4 Zookeeper

### 10.5 Netty

### 10.6 MongoDB

---
## 11 项目
三个项目： 
一个侧重Java Web开发、设计与整体架构。 
一个侧重数据库优化。 
一个侧重产品创意团队协作   

## 12 情景设计
#### 设计一个路由，为编号为1、2、3、4、5的五台服务器分配流量，期望比例为1：2：3：3：1
1. 方法1：利用随机数生成对应的服务器编号：`routeNum = (1/3)*random(1,5)+(1/3)*random(2,4)+(1/3)*random(3,4)`其中`random(n,m) = random(m-n)+n`表示随机生成`[n,m]`区间内的数字
2. 方法2：根据当前流量比例动态选择当前请求对应服务器编号

#### 如何设计一个RPC框架

#### 如何设计一个服务注册中心

#### 系统设计

1. 如何设计数据库系统，具体地，可以是设计 taobao/Facebook 或是任何公司的员工数据库等；
2. 如何设计用户系统，具体地，可以是 Netflix/Youtube 的用户系统等；
3. 如何设计支付系统，具体地，可以是 alipay 等；
4. 如何设计爬虫系统，具体地，可以是 baidu 的搜索引擎等；
5. 如何设计短网址系统，具体地，可以是新浪的短网址等；
6. 如何设计“秒杀”系统，具体地，可以是淘宝双十一系统等；
7. 如何设计 message 和 news feed 系统，具体地，可以是 facebook/人人 /微信朋友圈 /whatsapp/snapchat 等；
8. OOD 面向对象系统设计，具体地，可以是电梯问题、停车问题等；
9. 如何设计分布式文件系统，具体地，可以是 google 的文件分布系统 BFS 等；
10. 如何设计一个抖音推荐系统
11. 如何设计一个抖音评论系统